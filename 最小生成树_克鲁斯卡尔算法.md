## 最小生成树_克鲁斯卡尔算法

先看什么是最小生成树：最小生成树是在带权图中具有n个节点，选出n-1条边，得到连通图，使得这个连通图的权值和最小也就是最小生成树

##### 利用边集数组存图

边集数组：存储两个结点，以及两个结点之间的权值

```c++
struct Edge{
	int s,e,w;
}edge[105];

int n,m;

cin>>n>>m;
	
for(int i=0;i<m;i++){
	int x,y,m;
	cin>>x>>y>>m;
	edge[i].s = x;
	edge[i].e = y;
	edge[i].w = m;
}
```

##### 克鲁斯卡尔算法的思路：

###### 首先对边集数组进行排序

```c++
bool cmp(const struct Edge &a, const struct Edge &b){
	return a.w<b.w;	//按照权值，从小到大进行排序
}
sort(edge,edge+m,cmp);
```

###### 再遍历边集数组，对每次选择的一组结点，利用并查集判断选择之后会不会形成环，如果不会形成环，那么这一组结点和权值是我们要选择的一条边，否则就不是

```c++
int find(int x){
	while(x!=f[x]){
		return f[x]=find(f[x]);
	}
	return x;
}

bool is_cricle(int x,int y){
	int fx = find(x);
	int fy = find(y);
	
	if(fx != fy){
		f[fx] = fy;
		return false;
	}
	return true;
}

for(int i=0;i<m;i++){
	if(is_cricle(edge[i].s,edge[i].e) == false){
		cout<<"("<<edge[i].s<<","<<edge[i].e<<")："<<edge[i].w<<endl;
	}
}
```

以下是全部代码：

```c++
#include <iostream>
using namespace std;
#include <algorithm>

struct Edge{
	int s,e,w;
}edge[105];

int n,m;
int f[105];

bool cmp(const struct Edge &a, const struct Edge &b){
	return a.w<b.w;
}

int find(int x){
	while(x!=f[x]){
		return f[x]=find(f[x]);
	}
	return x;
}

bool is_cricle(int x,int y){
	int fx = find(x);
	int fy = find(y);
	
	if(fx != fy){
		f[fx] = fy;
		return false;
	}
	return true;
}

int main(){
	
	cin>>n>>m;
	for(int i=0;i<n;i++)
		f[i]=i;
	
	for(int i=0;i<m;i++){
		int x,y,m;
		cin>>x>>y>>m;
		edge[i].s = x;
		edge[i].e = y;
		edge[i].w = m;
	}
	
	sort(edge,edge+m,cmp);
	
	
	for(int i=0;i<m;i++){
		if(is_cricle(edge[i].s,edge[i].e) == false){
			cout<<"("<<edge[i].s<<","<<edge[i].e<<")："<<edge[i].w<<endl;
		}
	}
	
	return 0;
}
```

