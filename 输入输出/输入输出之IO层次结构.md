# 输入输出之IO层级结构

<img src="..\images\image-20240310150433445.png" alt="image-20240310150433445" style="zoom:67%;" />

从上往下一般是IO请求，从下往上每一层有每一层的工作内容

## 中断处理程序

中断处理程序负责处理中断发生时的所有操作，操作完成后阻塞，然后启动中断驱动程序来解决阻塞

## 设备驱动程序

设备驱动程序存放于设备控制器中，每一个设备控制器中都有存放寄存器的模块

设备驱动程序就是**把IO设备到设备控制器的转换代码**

设备驱动程序通常是操作系统内核的一部分，还有一种方案是构造用户空间的设备驱动程序，这种方案是为了防止干扰内核

### 驱动装载

在UNIX系统中如果要添加一个新设备，需要重新编译内核，将新的驱动程序装到内核中，这种也称为静态编译

然而随着大多数个人计算机的出现和IO设备的广泛应用，目前都使用动态编译的方式装载驱动

### 驱动功能

设备驱动程序具有很多功能，比如接受读写请求，对设备进行初始化，管理电源和日志，对输入参数进行有效性检查等

控制设备就是对设备发出指令，发出指令后，设备控制器便开始将这些指令写入设备寄存器，在每个指令写入控制器后，会检查控制器是否接受了这条命令并准备接受下一个命令，对于一系列的命令，设备控制器会依次检查

## 与设备无关的I/O软件

与设备无关的意思是不需要特定的设备

与设备无关的软件的基本功能是**对所有设备执行公共的IO功能**，并且**向用户层软件提供一个统一的接口**

功能：

​	缓冲

​	错误报告

​	设备驱动程序统一接口

​	分配和释放特定的设备

​	提供和设备无关的块大小

### 缓冲

无论是对于块设备还是字符设备来说，缓冲都是一个非常重要的考量标准

**假设无缓冲**：

<img src="..\images\image-20240311161114168.png" alt="image-20240311161114168" style="zoom:50%;" />

用户进程调用了读的系统调用，系统调用会阻塞当前的用户进程，用户进程会等待一个字符的到来，来一个字符中断一下，字符没到来之前一直在等待

**假设有缓冲**：

<img src="..\images\image-20240311161705487.png" alt="image-20240311161705487" style="zoom:50%;" />



用户进程设置缓冲区，只有缓冲区满的时候才会被中断

**问题**：缓冲区是从内存来的，是可以被调配的，这就造成了一个问题，如果字符接收的时候，用户进程中的缓冲区被调配走了

**解决方案：**在内核空间再设置一个缓冲区，用户空间的缓冲区防止一直被阻塞等待，内核空间的缓冲区用来接收之前要发给用户空间缓冲区的资源，当内核缓冲区要满的时候，主动调配一个缓冲区到用户空间

<img src="..\images\image-20240311162115991.png" alt="image-20240311162115991" style="zoom:50%;" />

**问题**：如果内核缓冲区和用户缓冲区都满了还有字符传来呢？

**解决方案：**再加入一个缓冲区

如果再加入的缓冲区也满了呢？那就再调配一个缓冲区到用户空间

以上所讲的就是双缓冲的解决方案，要注意：如果缓冲次数过多，会降低性能

### 错误处理

有一些错误是只有特定的设备才能处理，有一些是由框架进行处理，这些错误和特定的设备无关

程序编程错误（程序员解决）

实际的IO错误（设备驱动程序解决---->操作系统解决----->硬件解决）

### 设备驱动程序统一接口

操作系统是屏蔽硬件和软件的差异，类似于操作系统对用户所呈现的访问硬件的接口，设备驱动程序统一接口就是不管是什么厂商的设备，接入的时候必须是统一的接口

### 分配和释放特定的设备

操作系统判断某一个设备是否可以被分配使用和释放

## 用户空间的IO软件

虽然大部分IO软件都在内核结构中，但是还有一些在用户空间实现的IO软件，凡是没有绝对。一些IO软件和库在用户空间存在，然后以提供系统调用的方式实现

举例来说用户空间的IO软件是一些I/O库，就是用户通过用户空间，经过系统调用，访问内核

# 硬件

## 磁盘

<img src="..\images\image-20240311165302598.png" alt="image-20240311165302598" style="zoom:50%;" />



<img src="..\images\image-20240311165721375.png" alt="image-20240311165721375" style="zoom:50%;" />

磁头只有一个，数据存放在磁道上，磁盘的驱动程序来完成磁道寻址

## 磁盘格式化

磁盘在刚刚得到的时候是没有任何东西的，在使用磁盘的时候要进行磁盘格式化

**低级格式化**（磁盘的一些基本信息，存放在前导码中）

<img src="..\images\image-20240311170040274.png" alt="image-20240311170040274" style="zoom:67%;" />

ECC：在磁盘出现错误的时候可以进行错误处理，提高磁盘可靠性

**高级格式化**：记录文件系统相关信息

## 磁盘臂调度算法

一般情况下，影响磁盘块读写的时间由下面几个因素决定

​	寻道时间---寻道时间指的是就是将磁盘臂移动到需要读取磁盘块上的时间

​	旋转延迟---等待合适的扇区旋转到磁头下面所需的时间

​	实际数据的读取和写入时间

如果磁盘驱动程序每次接收一个请求并按照接收顺序完成请求，这种处理方式也就是 `先来先服务(First-Come, First-served, FCFS)` ，这种方式很难优化寻道时间。因为每次都会按照顺序处理，不管顺序如何，有可能这次读完后需要等待一个磁盘旋转一周才能继续读取，而其他柱面能够马上进行读取，这种情况下每次请求也会排队。

一种对先来先服务的算法改良的方案是使用 `最短路径优先(SSF)` 算法，下面描述了这个算法。

<img src="..\images\image-20240312104752238.png" alt="image-20240312104752238" style="zoom:50%;" />



<img src="..\images\image-20240312104829556.png" alt="image-20240312104829556" style="zoom:50%;" />

## 错误处理

磁盘在制造的过程中可能会有瑕疵，如果瑕疵比较小，比如只有几位，那么使用坏扇区并且每次只是让ECC纠正错误是可行的，如果瑕疵较大，那么错误不可能被掩盖

两种处理方法：

​	一种是在控制器中进行处理

​	一种是在操作系统层面进行处理

​	这两种方法经常替换使用



比如一个具有 30 个数据扇区和两个备用扇区的磁盘，其中扇区 4 是有瑕疵的。

<img src="..\images\image-20240312110248211.png" alt="image-20240312110248211" style="zoom:50%;" />

控制器能做的事情就是将备用扇区之一重新映射。

<img src="..\images\image-20240312110302828.png" alt="image-20240312110302828" style="zoom:50%;" />

还有一种处理方式是将所有的扇区都向上移动一个扇区

<img src="..\images\image-20240312110326101.png" alt="image-20240312110326101" style="zoom:50%;" />

## 稳定存储器

磁盘经常出现错误，导致好的扇区会变成坏扇区，驱动程序也有可能挂掉

我们期望磁盘能够准确无误的工作，但是事实情况是不可能的，但是我们能够知道的是，一个磁盘子系统具有如下特性：当一个写命令发给它时，磁盘要么正确地写数据，要么什么也不做，让现有的数据完整无误的保留。这样的系统称为 `稳定存储器(stable storage)`。稳定存储器的目标就是不惜一切代价保证磁盘的一致性。

### 稳定存储器的操作

稳定存储器使用两个一对相同的磁盘，对应的块一同工作形成一个无差别的块。稳定存储器为了实现这个目的，定义了下面三种操作：

- `稳定写(stable write)`

稳定写指的就是首先将块写到比如驱动器 1 上，然后将其读回来验证写入的是否正确，如果不正确，那么就会再次尝试写入和读取，一直到能够验证写入正确为止。驱动器 1 写入成功之后，才会对驱动器 2 进行写入和读取。

- `稳定读(stable read)`

稳定读指的就是首先从驱动器 1 上进行读取，如果读取操作会产生错误的 ECC，则再次尝试读取，如果所有的读取操作都会给出错误的 ECC，那么会从驱动器 2 上进行读取。

- `崩溃恢复(crash recovery)`

恢复程序扫描两个磁盘，比较对应的块。如果一对块都是好的并且是相同的，就不会触发任何机制；如果其中一个块触发了 ECC 错误，这时候就需要使用好块来覆盖坏块。



如果CPU崩溃了怎么办？

* 崩溃发生在写入之前，在恢复的时候就什么都不需要修改

<img src="..\images\image-20240312112120993.png" alt="image-20240312112120993" style="zoom:50%;" />

* 在写入驱动器1的时候崩溃，那就从驱动器2恢复驱动器1上的块

<img src="..\images\image-20240312112215854.png" alt="image-20240312112215854" style="zoom:50%;" />

* 溃发生在磁盘驱动器 1 之后但是还没有写驱动器 2 之前，这种情况下由于磁盘 1 已经写入成功

<img src="..\images\image-20240312112237901.png" alt="image-20240312112237901" style="zoom:50%;" />

* 崩溃发生在磁盘驱动 1 写入后在磁盘驱动 2 写入时，恢复期间会用好的块替换坏的块，两个块的最终值都是最新的

<img src="..\images\image-20240312112307215.png" alt="image-20240312112307215" style="zoom:50%;" />

* 崩溃发生在两个磁盘驱动写入后，这种情况下不会发生任何问题

<img src="..\images\image-20240312112325539.png" alt="image-20240312112325539" style="zoom:50%;" />

# 时钟

时钟也被称为定时器

时钟软件也是一种设备驱动的方式

## 时钟硬件

在计算机中有两种类型的时钟，这些时钟与现实世界中使用的时钟完全不一样

一种是连接到110V或220V的电源线上，这样每个电压周期会产生一个中断（不可编程）

一种是由晶体振荡器，计数器和寄存器组成（可编程）

<img src="..\images\image-20240312151841418.png" alt="image-20240312151841418" style="zoom:50%;" />

* 一键式时钟

当时钟启动时，会把存储器中的值复制到计数器中，然后，每次晶体的振荡器的脉冲都会使计数器 -1。当计数器变为 0 时，会产生一个中断，并停止工作，直到软件再一次显示启动。

* 方波时钟

在这种模式下，当计数器变为 0 并产生中断后，存储寄存器的值会自动复制到计数器中，这种周期性的中断称为一个时钟周期。

## 时钟软件

维护一天的时间

组织进程运行的时间超过其指定时间

统计CPU的使用情况

处理用户进程的警告系统调用

为系统各个部分提供看门狗定时器

完成概要刨析，监视和信息收集

## 软定时器

软定时器避免了操作系统在内核态和用户态的频繁切换