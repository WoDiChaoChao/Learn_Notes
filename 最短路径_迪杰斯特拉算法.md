## 迪杰斯特拉算法

迪杰斯特拉算法的思路是利用三个辅助变量和邻接矩阵计算最短路径的方法，三个辅助变量分别为记录距离的D数组，记录上次结点下标的P数组，还有记录是否找到当前节点的最短路径的Final数组

#### 首先利用邻接矩阵存图，这里直接使用二维数组模拟邻接矩阵

```c++
int map[100][100];
int n,m;
int D[100],P[100],Final[100];

cin>>n>>m;
for(int i=0;i<n;i++){
	for(int j=0;j<n;j++){
		if(i == j)
			map[i][j] = 0;
		else
			map[i][j] = INT_MAX;
	}
}

for(int i=1;i<=m;i++){
		int x,y,w;
		cin>>x>>y>>w;
		map[x][y] = map[y][x] = w;
}
```

#### 紧接着到达迪杰斯特拉算法的实现

首先输入源点

```c++
int s;
cin>>s;
```

然后初始化三个辅助变量，记录距离的D数组全部初始化为∞，录上次结点下标的P数组初始化为0，记录是否找到当前节点的最短路径的Final数组初始化为0，因为输入了源点，所以要更新与源点相关的变量

```c++
//P Final声明为全局变量，已经初始化全为0

D[s] = 0;	//源点到源点的距离为0
P[s] = s;	//源点到源点的路径为本身
Final[s]=1;	//源点到源点的最短路径已经找到

for(int i=0;i<n;i++){
		D[i] = INT_MAX;
}

//更新D数组和P数组，保存源点到与其直接相连点的距离和下标
for(int i=0;i<n;i++){
	D[i] = map[s][i];
	if(D[i] != INT_MAX)//源点到与下标为i的点直接相连
		P[i] = s;
}
```

然后循环n-1次，去寻找除源点外其他点到源点的最短距离

第一步：寻找保存距离最小的点，该点是从源点到该点距离最短的点，记录该点到源点的距离和点的下标

```c++
int minn;
int k;
for(int i=1;i<=n-1;i++){
	minn = INT_MAX;
	for(int j=0;j<n;j++){
		if(Final[j]==0 && D[j]<minn){
			k = j;
			minn = D[j];
		}
	}
}
```

第二步：更新Final数组，说明k点已经找到源点到k点的最短路径

```c++
Final[k] = 1;
```

第三步：继续以K点为源点，去寻找**与K点直接相连**，**没有找到最短路径**并且**源点到k点的距离加上k点到与其直接相连点的距离小于源点到与k点直接相连的距离**，也就是D数组中保存的值，如果找到这样一个点，就更新该点的D数组和P数组

```c++
for(int j=0;j<n;j++){
	if(map[k][j]!=INT_MAX && map[k][j]+minn < D[j] && Final[j]==0){
		D[j] = map[k][j]+minn;
		P[j] = k;
	}
}
```

最后，当循环n-1次之后，P数组中存放的就是源点到每个点的最短路径的下标值，也就是说，**迪杰斯特拉算法可以求得任意源点到其他任意点的最短路径**

完整代码如下：

```c++
#include <iostream>
using namespace std;
#include <limits.h>

int map[100][100];
int D[100],P[100],Final[100];
int n,m;

int main(){
	
	cin>>n>>m;
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			if(i == j)
				map[i][j] = 0;
			else
				map[i][j] = INT_MAX;
		}
	}
	
	for(int i=1;i<=m;i++){
		int x,y,w;
		cin>>x>>y>>w;
		map[x][y] = map[y][x] = w;
	}
	
	for(int i=0;i<n;i++){
		D[i] = INT_MAX;
	}
	
	int s;
	cin>>s;
	D[s] = 0;
	P[s] = s;
	Final[s]=1;
	
	
	for(int i=0;i<n;i++){
		D[i] = map[s][i];
		if(D[i] != INT_MAX)
			P[i] = s;
	}
	
	int minn;
	int k;
	for(int i=1;i<=n-1;i++){
		minn = INT_MAX;
		for(int j=0;j<n;j++){
			if(Final[j]==0 && D[j]<minn){
				k = j;
				minn = D[j];
			}
		}
		Final[k] = 1;
		for(int j=0;j<n;j++){
			if(map[k][j]!=INT_MAX && map[k][j]+minn < D[j] && Final[j]==0){
				D[j] = map[k][j]+minn;
				P[j] = k;
			}
		}
	}
	int e;
	cin>>e;
	cout<<e;
	while(e!=P[e]){
		cout<<"-->"<<P[e];
		e = P[e];
	}
	cout<<s;
	
	return 0;
} 
```

