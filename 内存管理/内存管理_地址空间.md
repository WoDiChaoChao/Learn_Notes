# 一种存储器抽象：地址空间

进程可以用来寻址内存的地址集合

每个进程都有它自己的地址空间，独立于其他进程的地址空间，但是父子进程不能独立

最简单的办法是使用动态重定位技术，它就是通过一种简单的方式将每个进程的地址空间映射到物理内存的不同区域

如何实现动态重定位技术？

​	基址寄存器和变址寄存器

​	基址寄存器存储起始位置，变址寄存器存储应用程序的长度

<img src="..\images\image-20240222110155753.png" alt="image-20240222110155753" style="zoom:60%;" />

## 交换技术

把一个进程完整的调入内存，然后在内存中运行一段时间，再把它放回磁盘

<img src="..\images\image-20240222142011068.png" alt="image-20240222142011068" style="zoom:67%;" />



逻辑层面操作系统把数据分成不同的段来存储

* 代码段：大小明确，存放指令或代码，还有一些常量
* 数据段：可读可写，存放初始化的静态变量和初始化的全局变量，生存期随着进程的结束而死亡
* bss段：可读可写，存放未初始化的静态变量和未初始化的全局变量
* rodata段：只可读，存放常量
* 栈：存放局部变量
* 堆：存放动态开辟的空间变量

内存增长处理方式

* 如果一个进程与空闲区相邻，那么可以把该空闲区分配给进程以供其增长
* 如果进程相邻的是另一个进程，就会有两种处理方式：要么把需要增长的进程移动到一个内存中空闲区足够大的区域，要么把一个或多个进程交换出去，生成一个大的空闲区
* 如果一个进程在内存中不能增长，而且磁盘上的交换区也满了，那么这个进程只有挂起一些空闲空间（或者可以结束该进程）

分配额外空间

<img src="..\images\image-20240222144135645.png" alt="image-20240222144135645" style="zoom:67%;" />

## 空闲内存的管理

* 位图

* 空闲列表

<img src="..\images\image-20240222144518812.png" alt="image-20240222144518812" style="zoom:67%;" />



按照地址顺序在链表中存放进程和空闲区

* 首次适配

  内存管理器会沿着段列表进行扫描

  首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表

  <img src="..\images\image-20240222151506952.png" alt="image-20240222151506952" style="zoom:50%;" />

* 下次适配

  每次找到合适的空闲区的时候，**记录当前的位置**，以便于下次寻找空闲区时从上次结束的地方开始搜索

  性能略低于首次适配

* 最佳适配

  试图找出最接近实际需要的空闲区

  假如要找到空闲区大小为2的空闲区

<img src="..\images\image-20240222152143637.png" alt="image-20240222152143637" style="zoom:50%;" />

​	最佳适配更容易划分出更零碎的内存碎片

* 最差适配

  总是分配最大的内存区域

* 为进程和空闲区维护各自独立的链表来提高性能（内存释放会非常慢）

* 快速适配

  对相同大小的内存空间或常用大小的内存空间维护链表，合并零碎空间的时候复杂且费时

