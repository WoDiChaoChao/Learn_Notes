# 虚拟内存

基本思想：每个程序都有自己的地址空间

地址空间被划分为多个称为页面的块

虚拟地址是对基址寄存器和变址寄存器的一种描述

## 分页技术

在任何一台计算机上，程序会引用使用一组内存地址，这些程序生成的地址被称为虚拟地址并形成虚拟地址空间

地址可以通过索引，基址寄存器，段寄存器或其他方式产生

内存管理单元：把虚拟地址映射为物理地址

<img src="..\images\image-20240225093716097.png" alt="image-20240225093716097" style="zoom:67%;" />



<img src="..\images\image-20240225093815738.png" alt="image-20240225093815738" style="zoom:50%;" />

## 存在映射的页如何映射 

虚拟地址空间由固定大小的单元组成，这种固定大小的单元被称为页

物理内存中也有固定大小的物理单元，称为页框

程序试图访问地址时 MOV REG,0

比如CPU将0号地址发送给MMU，MMU解析发现指向的是物理内存的8k-12K，然后MMU会将8k的地址发送到总线上

<img src="..\images\image-20240225094941804.png" alt="image-20240225094941804" style="zoom:50%;" />

##  未映射的页面如何映射（缺页）

修改映射关系，将存在映射的页面中不常用的映射取消掉，将未映射的页面来代替

## MMU是如何映射的

<img src="..\images\image-20240225101008608.png" alt="image-20240225101008608" style="zoom:67%;" />

## 页表

虚拟地址被分为虚拟页号（高位部分）和偏移量（低位部分）

虚拟页号作为页表的索引用来找到虚拟页中的内容，由页表项可以找到页框号（如果有的话），然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址

## 页表项

<img src="..\images\image-20240225101707303.png" alt="image-20240225101707303" style="zoom:50%;" />

保护位：0代表可读可写，1代表只可读不可写

修改位：重新分配页框

访问位：页面被访问的时候为1，不被访问的时候为0，在缺页处理的时候起作用

高速缓存禁止位：禁止该页面被高速缓存（从硬件设备接收I/O指令）



虚拟内存的本质：将虚拟地址内存空间分解为多个页面，并且将页面映射到物理内存的某一个页框

# 如何管理虚拟内存的抽象

虚拟地址到物理地址的映射速度必须要快

如果虚拟地址空间足够大，那么页表也会足够大

## 加速分页过程

实际情况是对少量的页面进行大量的访问

转换检测缓冲区（TLB）

TLB其实是一个缓存，对虚拟地址到物理地址的转换进行缓存

### 管理TLB软件

在以前，TLB管理都是硬件设计完成。现在几乎所有的页面管理都是在软件中完成的

当发生TLB访问丢失时，不再是由MMU到页表中查找，而是生成一个TLB失效并将问题交给操作系统解决

失效问题：

​	软失效和硬失效

​	软失效：TLB没有缓存对应的页面

​	硬失效：要访问的页面本身就不在内存中

其他失效问题：

所需要的页面存在内存中，但是却没有记录在进程的页表中------次要缺页错误

如果需要从硬盘直接调入页面--------严重缺页错误

程序可能访问了一个非法地址，根本无需向TLB中增加映射------段错误

## 针对大内存的页表

* 多级页表

  避免把全部页表一直保存在内存中。不需要的页表就不应该保留

<img src="..\images\image-20240225110533579.png" alt="image-20240225110533579" style="zoom:50%;" />

<img src="..\images\image-20240225110719300.png" alt="image-20240225110719300" style="zoom:50%;" />

* 倒排页表

  针对分页层级结构不断增加的情况

  **实际内存**中的每个页框对应一个表项，而不是每个虚拟页面对应一个表项

**![image-20240225111828402](..\images\image-20240225111828402.png)**

如果有经常访问的虚拟页面和页框，就将其存入到TLB缓存中