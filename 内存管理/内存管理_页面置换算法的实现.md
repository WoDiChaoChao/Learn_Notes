# 页面置换算法的实现

## 先进先出算法

```c++
#include <iostream>
using namespace std;
#include <algorithm>
#include <queue>

int n;
char c;
int a[100];

bool Search(queue<int> q, int value){
	bool flag = false;
	for(int i=0;i<q.size();i++){
		if(q.front() == value && !flag){
			flag = true;
		}
		else{
			int a = q.front();
			q.push(a);
			q.pop();
		}
	}
	return flag;
}

void FIFO(int *a, int frame_size, int a_size){
	queue<int> q;
	int lack=0;
	
	for(int i=0;i<a_size;i++){
		//该元素不在队列中而且队列中正在运行的页面数量小于限定的页面数量 
		if(!Search(q,a[i])){
			if(q.size() == frame_size){
				q.pop();
			}
			q.push(a[i]);
			lack++;
		}
	}
	cout<<"缺页次数："<<lack<<endl;
}


int input(){
	int sum=0,i=0;
	cout<<"该进程分配了几个页面"<<endl;
	cin>>n;
	cout<<"进程的访问序列"<<endl;
	getchar();
	char c0 = '10';
	while(scanf("%c",&c)){
		if(c0 >= '0' && c0<='9'){
			sum = sum*10 + (c0-'0');
			if(c < '0' || c > '9'){
				a[i] = sum;
				sum = 0;
				i++;
			}
		}
		
		if(c == '\n')
			break;
		c0 = c;
	}
	return i;
}

int main(){
	
	int size = input();
	FIFO(a,n,size);
	
	return 0;
}
```

## 第二次机会页面置换算法

```c++
#include <iostream>
using namespace std;
#include <algorithm>
#include <queue>

int n;
char c;
int a[100];

bool Search(queue<int> q, int value){
	bool flag = false;
	for(int i=0;i<q.size();i++){
		if(q.front() == value && !flag){
			flag = true;
		}
		else{
			int a = q.front();
			q.push(a);
			q.pop();
		}
	}
	return flag;
}

void LRU(int *a, int frame_size, int a_size){
	queue<int> q;
	int lack=0;
	
	for(int i=0;i<a_size;i++){
		//该元素不在队列中而且队列中正在运行的页面数量小于限定的页面数量 
		if(!Search(q,a[i])){
			if(q.size() == frame_size){
				q.pop();
			}
			q.push(a[i]);
			lack++;
		}
		else{	//如果元素存在队列，将此元素加入到队尾 
			int elem = a[i];
			for(int j=0;j<q.size();j++){
				int num = q.front();
				q.pop();
				if(num == elem)
					continue;
				q.push(num);
			}
			q.push(elem);
		}
	}
	cout<<"缺页次数："<<lack<<endl;
}


int input(){
	int sum=0,i=0;
	cout<<"该进程分配了几个页面"<<endl;
	cin>>n;
	cout<<"进程的访问序列"<<endl;
	getchar();
	char c0 = '10';
	while(scanf("%c",&c)){
		if(c0 >= '0' && c0<='9'){
			sum = sum*10 + (c0-'0');
			if(c < '0' || c > '9'){
				a[i] = sum;
				sum = 0;
				i++;
			}
		}
		
		if(c == '\n')
			break;
		c0 = c;
	}
	return i;
}

int main(){
	
	int size = input();
	LRU(a,n,size);
	return 0;
}
```

## 时钟页面置换算法（CLOCK）

```c++
#include <iostream>
using namespace std;
#include <algorithm>
#include <queue>

int n;
char c;
int a[100];
int ptr = 0; //模仿指针

//环形链表用数组实现 指针用全局变量
//如果该数组包含a[i]，不会发生中断 并且设置R位为1
//如果不包含，找到目前指针所指的位置，如果R位为0，更换data为a[i]，如果是1，设置为0，指针后移 
struct List{
	int data;
	int R; // 0  1
}; 

int Search_CLock(List* L, int L_size, int value){
	for(int i=0;i<L_size;i++){
		if(L[i].data == value)
			return i;
	}
	return -1;
}

void CLock(int *a, int frame_size, int a_size){
	int lack=0;
	List L[frame_size];
	int L_size = 0;
	int j=0;
	for(int i=0;i<a_size;i++){
		int opt = Search_CLock(L,L_size,a[i]);
		if(opt != -1){
			L[opt].R = 1;
		}
		else{
			lack++;
			if(L_size < frame_size){
				L[j].data = a[i];
				L[j].R = 1;
				L_size++;
				j++;
			}
			else if(L_size == frame_size){
				while(true){
					if(ptr == L_size)
						ptr=0;
					if(L[ptr].R == 0){
						L[ptr].data = a[i];
						L[ptr].R = 1;
						ptr++;
						break;
					}
					else if(L[ptr].R == 1){
						L[ptr].R = 0;
						ptr++;
					}
				}
			}
		}
	}
	cout<<"缺页次数："<<lack<<endl;
}


int input(){
	int sum=0,i=0;
	cout<<"该进程分配了几个页面"<<endl;
	cin>>n;
	cout<<"进程的访问序列"<<endl;
	getchar();
	char c0 = '10';
	while(scanf("%c",&c)){
		if(c0 >= '0' && c0<='9'){
			sum = sum*10 + (c0-'0');
			if(c < '0' || c > '9'){
				a[i] = sum;
				sum = 0;
				i++;
			}
		}
		
		if(c == '\n')
			break;
		c0 = c;
	}
	return i;
}

int main(){
	
	int size = input();
	CLock(a,n,size);
	return 0;
}
```

## 老化算法

```c++
#include <iostream>
using namespace std;
#include <algorithm>
const int N = 100;
#include<bitset>
struct CLock{
	int data[N]; //模拟访问的页号
	int size; //该时钟周期访问的页号数 
};

struct List{
	int data;
	unsigned char count;
};

int L_size; //L的大小 
List L[N]; //存储访问的页号 
int Clock_size; //时钟的个数 
CLock C[N]; //存储时钟周期内访问的页面 
void Input(){
	cout<<"List的大小？"<<endl;
	cin>>L_size;
	cout<<"现在装载的数据是？"<<endl;
	for(int i=0;i<L_size;i++){
		L[i].data = i;
		L[i].count = 0;
	} 
	
	cout<<"一共有多少个时钟"<<endl;
	cin>>Clock_size;
	
	for(int i=0;i<Clock_size;i++){
		cout << "第" << i+1 <<"次";
		cin>>C[i].size;
		for(int j=0;j<C[i].size;j++){
			cin>>C[i].data[j];
		}
	} 
}

int Search(int value){
	for(int i=0;i<L_size;i++){
		if(value == L[i].data)
			return i;
	}
	return -1;
}

int FindMin(CLock* C, int i){
	int min = C[i].data[0];
	for(int k=0;k<L_size;k++){
		if(C[i].data[k] < min)
			min = k;
	}
	return min;
}

void RightSet(){
	for(int i=0;i<L_size;i++){
		cout<< "L[" << i << "]:"<<L[i].data << "cnt:" << bitset<8>(L[i].count)<<endl;;
		L[i].count >>= 1;	
	}
	cout<<"-------------------------------------------"<<endl;
}

void Aging(){
	int lack = 0;
	for(int i=0;i<Clock_size;i++){
		for(int j=0;j<C[i].size;j++){
			int opt = Search(C[i].data[j]);
			if(opt >= 0){
				L[opt].count += 128;
			}
			else{
				lack++;
				int min_add = (C, i);
				L[min_add].data = C[i].data[j];
				L[min_add].count = 128;
			}
		}
		RightSet();
		
	}
}

int main(){
	
	Input();
	Aging();
	return 0;
}
```

