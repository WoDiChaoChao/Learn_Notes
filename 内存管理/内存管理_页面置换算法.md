# 页面置换算法

## 最优页面置换算法

在缺页中断发生时，这些页面之一将在下一条指令上被引用。其他页面则可能要到10，100或者1000条指令后才会被访问。那么将这些很晚才用到的页面进行置换

但是实际上无法预测哪些页面将要很晚才会使用

## 最近未使用页面算法（NRU）

状态位：每当引用页面（读入或写入）时都设置成R，写入（即修改）页面时设置M，由硬件来设置它们非常重要，如果硬件没有这些位，那么可以使用操作系统的缺页中断和时钟中断机制来进行模拟



启动一个进程后所有页面的R位和M位全部置零，R位定期时钟中断清零，M位不能定期清零，因为修改之后要写入磁盘

* 没有引用R，没有修改M
* 没有引用R，已经修改了M
* 引用R，没有修改M
* 引用R，修改M

当发生缺页中断时，要置换的页面应是没有引用R，也没有修改M的页面

## 先进先出置换算法（FIFO）

由操作系统维护一个所有在当前内存中的页面的链表，最早进入的放在表头，最新进入的放在表尾

在发生缺页异常时，会把头部的页移除并且把新的页添加到表尾

<img src="..\images\image-20240226144237144.png" alt="image-20240226144237144" style="zoom:50%;" />

 先进先出的缺陷：不会检查移除的页面是不是常用的页面或者正在使用

## 第二次机会页面置换算法（SC）

避免把经常使用的页面置换出去

我们检查表头页面的R位，如果是0，那么这个页面没有被使用，立刻换出，如果R位是1，那么就清楚此位为0，此页面会被放在链表的尾部，然后继续搜索有没有R为0的

缺陷：当所有页面的R位都是1，就会被简化为单纯的先进先出

## 时钟页面置换算法（CLOCK）

对第二次机会算法的改进（减少链表的插入移动操作）

把所有的页面保存在一个环形链表中，指针指向的永远是最老的页面

<img src="..\images\image-20240226145419371.png" alt="image-20240226145419371" style="zoom:50%;" />

## 最近最少使用页面置换算法（LRU）

在缺页中断时，置换未使用时间最长的页面

用软件模拟LRU

​	最不常使用置换（NFU）

​	用一个软件计数器来和每个页面关联，用来跟踪每个页面使用的次数（+R位），当发生缺页中断	时，置换次数最少的页面

​	NFU最主要的问题是它不会忘记任何东西，当一个常用的页面变为一个不常用的页面，但是之前因为常用导致计数器记录的次数很大，但是实际上该页面已经不再使用了

老化算法

​	首先，在R位被添加进来之前先把计数器右移一位

​	第二步，R位被添加到最左边的位而不是最右边的位



<img src="..\images\image-20240226152057006.png" alt="image-20240226152057006" style="zoom:50%;" />

问题：计数器是有上限的

## 工作集置换算法

* 请求调页

  刚启动进程时，在内存中并没有页面。此时如果CPU尝试匹配第一条指令，就会得到一个缺页异常，使操作系统装入含有第一条指令的页面

* 进程以局部性方式进行工作

* 一个进程当前正在使用的页面的集合称为它的工作集

  如果内存太小而无法容纳整个工作集，那么进程的运行过程中会产生大量的缺页中断，会导致运行速度也会变得缓慢-------颠簸

* 在多道程序的系统中，通常会把进程移到磁盘上（即从内存中移走所有的页面）

* 当进程想要再次把之前调回磁盘的页面调回内存怎么办？（发送缺页中断信号）

* 工作集模式/预先调页

  分页系统中设法跟踪进程的工作集，确保这些工作集在进程运行时调入内存

<img src="..\images\image-20240226154056850.png" alt="image-20240226154056850" style="zoom:50%;" />



<img src="..\images\image-20240226154312553.png" alt="image-20240226154312553" style="zoom:67%;" />

如果R==0，实际时间 - 上一次使用的时间 < 时钟周期，代表这个页面可能会用，如果实际时间 - 上一次使用的时间 > 时钟周期，置换该页面

## 工作集时钟页面置换算法

<img src="..\images\image-20240226155143790.png" alt="image-20240226155143790" style="zoom:67%;" />

* 所有的页面都有可能因为磁盘IO在某个时钟周期内被调度，防止此操作造成的磁盘阻塞，设置一个最大允许写回n个页面。

* 指针绕了一圈回到起点

  至少调度了一次写操作

  ​		指针不停的移动，寻找第一个未被修改过的页面

  没有调度过写操作

  ​		置换一个未被修改的页面来使用

​	