## 重新认识输入和输出

C++语言本身未定义任何输入输出语句，而是有一个全面的标准库来提供I/O机制，就是iosream库

### 输出（向流写入数据）

向流写入数据

```c++
std::cout << "Enter two numbers：" << std::endl;
```

**<<**运算符接受两个运算对象，左侧必须是ostream（输出流）对象，右侧是要打印的值，此运算符将给定的值写到给定的ostram对象中保存在缓冲区内，直到遇到**std::endl**的时候就会刷新缓冲区到目标设备，如果没有**std::endl**会一直向缓冲区写入数据，直到程序运行结束，再刷新到目标设备

C++对**<<**运算符进行了重载

```c++
std::ostream& operator<<(std::ostream& os, const T& obj);
```

<< 接收两个参数，一个标准输出流对象，一个要输出的值，返回的是标准输出流对象，这就解释了为什么可以链式输出

### 输入（从流读取数据）

向流写入数据

```
std::cin >> v1 >> v2;
```

**>>**运算符接受两个运算对象，左侧必须是istream（输入流）对象，右侧是内置类型变量，此运算符是从输入流中读取数据存入内置类型变量v1和v2中，每次读取遇到空白字符就跳过，遇到非空白字符就继续读取，直到遇到回车符结束读取

## 含有无符号类型的表达式

当算术表达式中既有无符号数也有有符号数时，有符号数会转化为无符号数进行运算，有符号数转化为无符号数就是有符号数加上无符号数的模

例如：

```c++
unsigned int u = 10;
int i = -42;
cout<< i+i <<end; //会输出-84 结果和我们预想的一样
cout<< u+i <<endl; 
//int占4个字节，32个比特位，-42+2^32 = 4294967254, 4294967254+10 = 4294967264
//输出4294967264
```

所以在做运算的时候，避免将无符号数和有符号数混合使用，即使两个无符号数进行运算，也要保证结果不为负数

## 认识extern

#### 声明和定义

声明不会向内存中申请空间

定义会向内存中申请空间，声明时候初始化就是定义

```c++
extern int i; //声明，不会向内存中申请空间
int i; //既是声明也是定义
extern int i = 10; //定义
```

## const文件共享

默认状态下，const修饰的全局变量仅在文件内有效，当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量

但是有时候要实现const变量在文件之间共享，解决方案就是使用extern

在一个文件中使用extern定义const变量，另一个文件中声明这个变量，就可以实现在一个文件中定义，多个文件中声明使用const变量了

a.cpp

```c++
extern const int v = 10； //使用extern定义const变量
```

b.cpp

```c++
extern const int v;	//另一个文件中声明这个变量
cout<<v<<endl;//输出10
```

注意，声明的文件中不用写包含代码

## 类型转换

**隐式类型转换**：

* 比int类型小的整型值首先提升为较大的整数类型
* 在条件中，非布尔值转换为布尔类型
* 初始化过程中，初始值转换成变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型
* 算术运算如果有多种类型，转换成同一种类型

**算术转换**：运算符的运算对象将转换为最宽的类型

**整型提升**：把小整数类型转换成较大的整数类型，前提是转换后的类型能容纳原类型所有可能的值，比如char，signed char，unsigned char，short，unsigned short，它们所有的值都能存在int类型中，那么它们就会提升为int类型

**显示转换**：

* static_cast

  主要用于基本数据类型之间的转换，编译时检查，不能用于不相关的指针类型之间进行转换

  ```c++
  double num = 3.14;
  int int_num = static_cast<int>(num);
  cout<<int_num<<endl;
  
  //输出3
  ```

* const_cast

  添加或移除const属性

  ```c++
  const int myConstInt = 42;
  int myInt = const_static<int>(myConstInt); //移除了const属性，可以进行更改
  ```

* reinterpret_cast

  通常用于指针和整数类型之间的转换

  ```c++
  int myInt = 42;
  double* myDoublePtr = reinterpret_cast<double*>(&myInt);
  ```

## goto语句

goto语句可以在程序中实现无条件跳转

**基本语法**：

```c++
goto label_name;

// ...

label_name:
// 代码块
```

这里的 `label_name` 是用户定义的标签，可以在程序中的任何地方使用。当执行到 `goto label_name;` 语句时，程序将会跳转到 `label_name` 标签所在的位置，继续执行代码。

示例：

```c++
#include <iostream>

int main(){
    
    int i = 0;
    loop_start:
    if(i < 5){
        cout<<i<<" ";
        i++;
        goto loop_start;
    }
    
    return 0;
}
```

