# 操作系统之进程和线程

## 操作系统总览

### 程序从创建到运行的过程

```c++
#include <stdio.h>
int main(){
    printf("hello world\n");
    return 0;
}
```

任何一个程序的生命周期都是从一个源文件开始的，源文件都是从main函数开始的，电脑上的任何信息都是以二进制的形式去记录的，那么源代码本质上是由0和1组成的一些序列，又将8位看作一个整体作为一个字节，用字节来表示程序中的字符

正是因为所有信息都是由二进制表示的，那么由二进制转为八进制，十进制，十六进制的编码来表示字符，比如ascall码，用这种编码来表示文本字符

#### 程序如何向操作系统迈进的？

将程序变为一个可执行的目标文件，以二进制的形式存入磁盘，就是程序向操作系统迈进的过程，这整个过程都是由编译器完成的，编译器在这个过程中分为了四步

* 预处理过程（生成 .i 文件）

  将我们需要引用的所有内容插入到源文件

  命令：gcc -E hello.c -o hello.i

  <img src=".\images\image-20240201191911893.png" alt="image-20240201191911893" style="zoom: 50%;" />

<img src=".\images\image-20240201191938589.png" alt="image-20240201191938589" style="zoom: 33%;" />

* 编译阶段（生成 .s 文件）

  将预处理过后的.i文件翻译成**汇编程序**，这一阶段**保证了操作系统与机器一对多的性质，因为汇编是所有操作系统都可以识别认证的**，此时不同的语言经过不同的编译器经过一系列过程变成了通用的汇编语言

  命令：gcc -S hello.i -o hello.s

  <img src=".\images\image-20240201192203154.png" alt="image-20240201192203154" style="zoom:50%;" />

<img src=".\images\image-20240201192223060.png" alt="image-20240201192223060" style="zoom:33%;" />

* 汇编阶段（生成 .o 文件）

  **汇编器**将 .s 文件翻译成**机器语言指令**

  命令：gcc -c hello.s -o hello.o

<img src=".\images\image-20240201193225204.png" alt="image-20240201193225204" style="zoom:50%;" />

<img src=".\images\image-20240201193244521.png" alt="image-20240201193244521" style="zoom:50%;" />

* 链接阶段（生成可执行文件）

**链接器**把需要调用的一些标准库文件(其他的目标文件)链接到文本文件当中，最终结果是得到一个可执行文件，然后加载到内存中，交给操作系统去执行

### 操作系统是如何区分和识别代码的

像一篇文章一样，要知道人物的心理是需要上下文的，操作系统也一样，也是通**过所谓的上下文来区分代码**，对于所有的程序，是只有上文，没有下文的

### 计算机常见硬件

处理器，内存，键盘，鼠标，显示器，网络接口，打印机等等所有的硬件在操作系统中都有对应的映射，除了像鼠标键盘这种I/O设备，程序员不会直接和硬件打交道，都会在硬件中封装一层软件，而这个软件就是**操作系统**，说白了，**操作系统就是建立一个和计算机硬件一一对应的计算机模型**

<img src=".\images\image-20240201201328871.png" alt="image-20240201201328871" style="zoom:50%;" />

操作系统是运行在内核态的，内核态其实就是操作系统的一种运行状态，操作系统是有硬件的访问权的，是可以执行机器中能够运行的任何指令；软件的其余部分全部运行在用户态，对接应用程序的一些接口，越靠近用户态上级的地方越容易编写；操作系统的主要目的是保护硬件



<img src=".\images\image-20240201202010013.png" alt="image-20240201202010013" style="zoom:50%;" />

​																							        简单个人计算机的组件

根据这个简单的个人计算机的组件可以抽象出最经典的系统硬件组成的模型

<img src=".\images\image-20240201202249116.png" alt="image-20240201202249116" style="zoom:50%;" />

* CPU：中央处理单元，处理和执行一些指令，计算机的大脑，处理的指令是从内存来的，任何时候CPU都是通过地址指向主存中的机器指令。
* 寄存器(PC)
  * 程序计数器：CPU不是直接与主存进行交互的，是通过程序计数器(寄存器)与主存交互的，程序计数器(寄存器)中存储指向下一条指令的地址
  * 通用寄存器：CPU从内存中获取指令的时间要远远大于CPU执行一条指令的时间，这个时候，寄存器会保存上一条指令执行的结果，程序记数器是通用寄存器的一环，通用寄存器还可以保存堆栈指针
  * 程序状态寄存器：跟踪当前系统的状态，在系统调用和输入输出起着关键作用

回到CPU，刚刚说到的内核态和用户态都存在于CPU中，通过程序状态寄存器中的一个二进制位可以控制CPU的状态是内核态还是用户态，当运行在内核态中，CPU可以执行指令集中的任何指令，并且可以使用硬件，如果运行在用户态中，有很多指令是被禁止的，比如内存保护相关指令，所以在这种状态下如何使用这些指令呢，那就需要用到用户接口程序来调用系统服务，所以用户接口程序就是转换内核态

### 取指单元,解码单元,执行单元

传统的CPU是读取指令，解码指令，执行指令三个环节一一执行，但是现代CPU是把三部分分开独立起来，在一个CPU中分为取指单元，解码单元，执行单元，为的是提高性能

**超标量流水线**：多个取指单元同时读取指令，进行解码，然后放到缓冲区，紧接着后面哪个执行单元空了就放到哪个单元，这种形式更偏向于无序的情况

<img src=".\images\image-20240201211616578.png" alt="image-20240201211616578" style="zoom:50%;" />

### 内存

内存的理想状态是存储空间又大，价格又便宜，而且让CPU读取信息又快，但是以目前的技术手段实现不了，就对内存进行了分层

<img src=".\images\image-20240201214220585.png" alt="image-20240201214220585" style="zoom:50%;" />

* 高速缓存：由硬件控制，是由主存分割出来的高速缓存行，高速缓存会检查需要的高速缓存行是否存在于高速缓存行中，因为寄存器和主存的访问时间相差还是很大的，而且CPU执行指令的时间远远快于从寄存器中读取指令的时间，高速缓存是在主存和寄存器之间做的缓存，就是为了提高寄存器读取指令的效率

  * 什么时候把新的内容存放进缓存？
  * 新的内容存在在缓存的哪一行？
  * 当我们需要新的空间作为缓存，应该移除哪块内容？
  * 移除的内容放在哪？

  由这四个问题引申出许多种缓存系统，在现代CPU种，主要有两种缓存

  * 第一级放在CPU内部，用来将已经解码的指令调入CPU的执行引擎
  * 第二种缓存，用来存放最近使用的关键字

* 主存：

  * RAM（随机访问存储器）
    * RAM是一种易失性存储器，这意味着当断电时，其中存储的数据会丢失。
    * RAM允许计算机随机地读取或写入数据，因此称为“随机存取存储器”。
    * RAM通常用于存储正在运行的程序和临时数据，包括操作系统和应用程序。
    * RAM的速度很快，但容量相对较小，且数据不持久。
  * ROM（只读存储器）
    * ROM是一种非易失性存储器，这意味着其中存储的数据不会因为断电而丢失。
    * ROM的内容在制造时被预先设定，并且一般情况下无法修改，因此称为“只读存储器”。
    * ROM用于存储固定的程序和数据，如计算机的基本引导程序（Bootstrap Loader）和固件（Firmware）等。
    * ROM通常用于存储一些需要在计算机启动时立即访问的数据和指令。

* 磁盘：访问速度慢，保存文件信息

  * 磁盘访问慢的原因是磁盘的构造（寻道时间，磁盘碎片化等等）

  <img src=".\images\image-20240202150516179.png" alt="image-20240202150516179" style="zoom:50%;" />

<img src=".\images\image-20240202150658014.png" alt="image-20240202150658014" style="zoom:50%;" />

<img src=".\images\image-20240202150803214.png" alt="image-20240202150803214" style="zoom:50%;" />

内存访问速度很快，但是成本大，存储空间小，使用很多的内存意味着消耗的成本很昂贵，所以就需要存储空间很大的磁盘来充当内存，但是磁盘的访问速度很慢，那么如何解决访问速度不匹配的问题呢？解决方法就是利用缓存，在磁盘中做了内存地址的映像，把经常访问的地址映射到主存，使其提高访问速度

### I/O设备

I/O设备主要分两大类，一类是我们可以看得到的设备，比如键盘鼠标，打印机，显示器等，另一类是一些控制器，USB控制器，硬盘控制器，这些控制器就是一个个小芯片，这些控制器对于I/O设备来说就是操作系统，目的是为了屏蔽各种物理细节

实现输入和输出的方式有三种：

* 忙等待

  当一个设备要输入的时候，操作系统将输入的控制权交给该设备，该设备去占据CPU，其他的输入设备只能等待，当该设备工作完成，再将CPU的控制权交还给调用者

* 中断

  中断是为了解决忙等待的问题，在忙等待中，当一个设备正在执行输入输出操作时，操作系统或应用程序需要不断地轮询设备状态，从而导致 CPU 被长时间占用。而中断机制允许设备在需要时发送中断请求，CPU 可以继续执行其他任务，直到设备就绪并触发中断。

  <img src=".\images\image-20240202161636854.png" alt="image-20240202161636854" style="zoom:50%;" />

  一开始磁盘驱动器会在CPU中下一个驱动

  1:CPU告诉磁盘控制器，磁盘可以开始工作了

  2：发送中断信号到中断控制器，信号的接受与否看该信号的优先级

  3 4: 中断控制器接收信号，将信号传给CPU，CPU执行中断信号，此时会记录被中断设备在结   		束运行时的一些信息和地址，这些信息会保存到被中断设备的寄存器中，然后CPU瞬间切		换到内核态 

* 直接存储器访问（DMA）

### 将设备驱动器装入操作系统

* 第一个途径是将内核与设备启动程序重新连接，然后重启系统
* 第二个途径是在一个操作系统文件中设置一个入口，通知该文件需要一个设备驱动程序，然后重新启动系统。在重启系统时，操作系统会寻找有关的设备启动程序并把它装载
* 第三个途径是操作系统能够在运行时接收新的设备驱动程序并立刻安装，无需重启操作系统

### 总线(BUS)

* 总线就跟公共汽车一样
* 公共汽车的站点----------多个设备或者接入点
* 乘客------------传输的数据包
* 车是有容量的，所以传输的信息也是有容量的---------字节块
* 车辆谁先走，谁后走，走哪站，需要有顺序，有规定----------控制器 

<img src=".\images\image-20240202165745634.png" alt="image-20240202165745634" style="zoom:50%;" />

### **硬件支持系统，系统管理硬件**

* 操作系统其实就是一个建立在应用程序和硬件之间的一道桥梁
* 基本功能：
  * 防止硬件被滥用
  * 通过一种比较简单的机制匹配对应的应用程序，进而控制复杂的硬件
* 对硬件进行抽象
  * 进程(处理器，主存，I/O设备)
  * 虚拟内存(主存和磁盘)
  * 文件(I/O设备)

#### 进程

* 进程的本质就是操作系统执行的一个程序

* 与进程相关

  * **地址空间------存放的是可执行程序**
  * **资源集-------通常包括寄存器，打开文件的清单，突发的报警，有关的进程清单和其他需要执行程序的信息**

  

  假设一种场景

  ​	用户启动一个视频剪辑程序，指示它按照某种格式转换视频，然后去浏览网页，同时，一个	检查电子邮件的后台进程被唤醒并开始运行

  ​	这是三个独立的活跃进程，CPU不是同时执行这三个进程，而是不断轮换，挂起一个进程，执行一个进程，只不过是轮换的时间非常快，在切换的时候，也叫做中断，**在挂起一个进程转而执行另一个进程的时候，会将挂起进程当前的所有状态信息保存在操作系统的进程表中**

  

  进程挂起包括：

* 进程的地址空间----磁盘映像

* 进程表项（进程当前的所有状态信息存储在进程表中）

  与进程管理有关的最关键的系统调用往往是决定着进程的创建和终止的系统调用

  

  进程间通信

* 合作完成某些作业的相关进程经常需要彼此通信来完成

* 那么信息丢失怎么办？

  * 利用定时器来防止信息丢失，当进程A给进程B发送信息后，定时器开始启动，在若干秒后，操作系统会向进程B发送一个确认通知，如果进程B没收到刚刚信息，操作系统会向进程A发送警告，然后进程A重新发送信息，在等待确认的过程中进程A会被挂起 

#### 线程

* 线程是操作系统能够运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位
* 为什么会有线程的概念？
  * 进程的颗粒度太大，线程主要共享的是进程的地址空间，进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同

#### 地址空间

在一个非常简单的操作系统中，仅仅有一个应用程序运行在内存中，为了运行第二个应用程序，需要把第一个应用程序移除才能把第二个程序装入内存

复杂一些的操作系统会允许多个应用程序同时装入内存中运行，为了防止应用程序之间相互干扰，就引出了地址空间，每个程序都有属于自己的地址空间

#### 虚拟内存

进程直接访问物理地址会带来不可预估的风险

物理内存资源是宝贵且非常有限

内存分配时，连续内存分配会产生很多难以分配的内存碎片

为了避免这些问题，从而引出了虚拟内存

虚拟内存是一种解决方案，用于解决计算机系统中的内存管理和资源限制问题

1. **扩大可用内存空间**：虚拟内存允许程序使用比物理内存更大的地址空间，因为它可以使用硬盘空间作为临时的扩展内存。
2. **提高系统的响应速度和效率**：通过将不活跃的内存页面存储到硬盘上，并在需要时将其重新加载到物理内存中，虚拟内存能够优化内存的使用，提高系统的整体性能和响应速度。

形象理解：

想象你有一个小房子（代表你的计算机的物理内存），这个房子有一定的空间，但是不够大。现在你想装入很多家具（代表程序和数据），但是家具太多，无法一次性全部放进房子里。

虚拟内存就好像你在房子外面有一个储藏室（代表硬盘），你可以把一部分不经常使用的家具放到储藏室里。当你需要某件家具时，你可以把它从储藏室取出放到房子里使用，同时可以把另一件不需要的家具放回储藏室。这样，你的房子看起来就好像有很大的空间一样，虽然实际上你只是用了有限的房间和储藏室。

这个例子中：

- 房子就是物理内存，有限的、可见的内存空间。
- 储藏室就是硬盘，无限的、不可见的存储空间。
- 家具就是程序和数据，需要被存储和使用。

虚拟内存的作用就是扩大了你可用的内存空间，使得你能够运行更多的程序和处理更多的数据，而不受物理内存大小的限制。

#### 文件

几乎所有操作系统都支持的另一个关键概念就是文件系统

对文件的所有操作几乎全部需要系统调用

操作系统的一项主要功能是屏蔽磁盘和其他I/O设备的细节特性，给程序员提供一个良好，清晰的独立于设备的抽象文件模型

保存文件的地址：目录

<img src=".\images\image-20240203145514627.png" alt="image-20240203145514627" style="zoom:50%;" />

#### 管道

是一种虚文件，用来连接两个进程

<img src=".\images\image-20240203150428747.png" alt="image-20240203150428747" style="zoom:50%;" />

#### 并发和并行

并发和并行是既相似又有区别的两个概念

​	并行是指两个或者多个事件在同一时刻发生

​	并发是指两个或多个事件在同一时间段内交替发生

#### 系统调用

操作系统提供两种功能

​	为用户提供应用程序抽象

​	管理计算机资源

只有系统调用能进入内核态，操作硬件

<img src=".\images\image-20240203152103526.png" alt="image-20240203152103526" style="zoom:50%;" />

假如现在是一个读文件的C语言代码

1 2 3：传入读取文件相关的参数

4：调用函数

5：调用之后，把代码进行分区放置到虚拟内存（因为是临时数据）

6：进入内核态

7 8：内核态中执行系统调用

9：返回给用户

系统调用的分类：

* 用于进程管理的系统调用

* 用于文件管理的系统调用
* 用于目录管理的系统调用

#### 操作系统结构

* 单体结构(最常用)

  单体结构和我们平时写的代码一样，是以单一的程序来进行运行的

  优点：调用任何一个所需要的程序都非常高效

  缺点：成千上万的调用显得臃肿，笨拙，只要系统发生故障，任何程序将不可用，这往往是灾			难性的

<img src=".\images\image-20240203153411362.png" alt="image-20240203153411362" style="zoom:50%;" />

* 分层系统

  利用层级来分隔不同的功能，分层结构中的所有功能都存放于内核态中

* 微内核

  传统上，所有层都在内核中，但是这样做没有必要

  尽可能减少内核态中功能可能是更好的做法

  只有一个模块----微内核------运行在内核态，其余模块可以作为普通用户进程运行在用户态

  <img src=".\images\image-20240203154053721.png" alt="image-20240203154053721" style="zoom:50%;" />

  

* 客户-服务端系统

<img src=".\images\image-20240203154230152.png" alt="image-20240203154230152" style="zoom:50%;" />

## 进程

在操作系统中，进程是指计算机中正在运行的程序的实例。一个进程包括了程序的执行代码、数据和所需的系统资源，例如内存、CPU时间、文件和设备等。每个进程都被操作系统视为独立的实体，拥有自己的地址空间和执行环境。进程之间可以相互通信和交互，但彼此之间是相互独立的，通常由操作系统进行调度和管理。

<img src=".\images\image-20240203183823310.png" alt="image-20240203183823310" style="zoom:40%;" />

### 支持多进程的多道程序系统

严格意义来说，在某一瞬间，CPU只能运行一个进程

* 伪并行：

  伪并行是指单核或多核处理器同时执行多个进程，从而使程序更快

因为CPU执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪

### 进程模型

<img src=".\images\image-20240207174625669.png" alt="image-20240207174625669" style="zoom:50%;" />



<img src=".\images\image-20240207175447155.png" alt="image-20240207175447155" style="zoom:50%;" />



<img src=".\images\image-20240207175523708.png" alt="image-20240207175523708" style="zoom:50%;" />

### 进程的创建

* 系统初始化
* 正在运行的程序执行了创建进程的系统调用
* 用户请求创建一个新进程
* 初始化一个批处理工作

#### 系统初始化

启动操作系统时，系统通常会自动创建若干个进程

分类：

​	前台进程：可以和用户做交互

​	守护进程：一般处于休眠状态（比如后台邮件接收进程）

#### 系统调用创建

除了在启动阶段创建进程之外，一些新的进程也可以在后面创建。通常一个正在运行的进程会发出系统调用来创建一个或多个新进程来帮助其完成工作

#### 用户请求创建

输入一个命令或者双击图标打开的一个程序

#### 批处理创建

批处理创建是指一次性创建多个进程的过程。通常情况下，批处理创建用于批量处理任务，例如在批处理文件中列出一系列需要执行的命令或程序，然后一次性执行这些命令或程序，从而创建多个进程并同时运行它们。

### 进程的终止

* 正常退出(自愿的)
* 错误退出(自愿的)
* 严重退出(非自愿的)
* 被其他进程杀死(非自愿的)

### 进程的层次结构

**UNIX进程体系**

<img src=".\images\image-20240207192617408.png" alt="image-20240207192617408" style="zoom:50%;" />

**Windows进程体系**

Windows中没有进程层次的概念，Windows中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌(成为句柄)，该句柄可以用来控制子进程

### 进程的状态

尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助

<img src=".\images\image-20240207193540410.png" alt="image-20240207193540410" style="zoom:50%;" />

1：等待输入而阻塞

2：调度程序根据优先级选择一个程序，将其从运行状态变为就绪态

3：调度程序根据优先级选择一个程序，将其从就绪状态变为运行态

4：执行有效的输入后，阻塞态变为就绪态

```shell
cat chapter1 chapter2 chapter3 | grep tree

grep tree执行完后进入阻塞状态，等待有效的输入，cat chapter1 chapter2 chapter3执行完后对grep tree进行了有效输入，进程从阻塞态变为就绪态，如果此时没有其他的进程执行或者说该进程优先级足够高，调度程序会选择将其从就绪态变为运行态进行运行
```

阻塞态是我必须等外部的某个事件发生以后我才能运行，否则我不能运行

就绪态是我本身已经可以运行了，但是由于有一些其他优先级较高于自己的进程正在运行，我不能运行

## 线程

为什么要在进程的基础上再创建一个线程 

* 多线程之间会**共享同一块地址空间和所有可用数据**的能力，这是进程所不具备的
* 线程要比进程更**轻量级**，更容易创建和撤销，操作起来更容易

### 线程的使用

* 多线程解决方案：

<img src=".\images\image-20240209142317700.png" alt="image-20240209142317700" style="zoom:50%;" />

​			以Web服务器为例，调度线程通过读入网络请求，然后选择空闲(睡眠)的工作线程来处理请求(阻塞变为就绪)

* 单线程解决方案

  单线程和多线程类似，区别就在于，单线程模型只有一个工作线程

* 状态机解决方案

  当管理线程时，状态机被用来描述线程的生命周期和状态转换，包括创建、就绪、运行、阻塞和终止等状态。操作系统根据这个状态机模型和外部事件来控制线程的状态转换，例如，当一个线程处于阻塞状态时，如果等待的事件发生，它会转换为就绪状态。

| 模型       | 特性                             |
| ---------- | -------------------------------- |
| 单线程     | 无并行性，性能较差，阻塞系统调用 |
| 多线程     | 有并行性，阻塞系统调用           |
| 有限状态机 | 并行性，非阻塞系统调用，中断     |

### 经典的线程模型

线程：进程中的执行单元，轻量级的进程

<img src=".\images\image-20240209151616609.png" alt="image-20240209151616609" style="zoom:50%;" />



<img src=".\images\image-20240209151759804.png" alt="image-20240209151759804" style="zoom:50%;" />

### 线程的系统调用

单线程--->通过某个库函数--->新的线程(Exit Join yield)--->线程消失

Exit：退出

Join：主程序等待线程调用结束继续执行

yield：允许此线程自动放弃CPU，让另一个线程运行(线程无法使用时钟中断让出CPU)

### POSIX线程

为了使编写可移植线程程序成为可能，IEEE在IEEE标准1003.1c中定义了线程标准

| 线程调用             | 描述                           |
| -------------------- | ------------------------------ |
| pthread_create       | 创建一个新线程                 |
| pthread_exit         | 结束调用的线程                 |
| pthread_join         | 等待一个特定的线程退出         |
| pthread_yield        | 释放CPU来运行另外一个线程      |
| pthread_attr_init    | 创建并初始化一个线程的属性结构 |
| pthread_attr_destory | 删除一个线程的属性结构         |

### 线程实现

* 在用户空间中实现线程

<img src=".\images\image-20240209153736668.png" alt="image-20240209153736668" style="zoom:50%;" />

```
所有的进程和线程全部在用户空间，内核完全不知道它们的存在，而进程和线程是在运行时系统之上实现的，运行时系统也叫运行时的环境，是用来管理线程运行过程(创建，终止，等待......)的集合，线程表用来跟踪进程中的线程，和内核中的进程表类似

优势：
	启动线程效率更高(不需要切换内核，不需要上下文切换，也不需要对内存高速缓存的刷新)
	允许每个进程有自己定制的调度算法
弊端：
	如何实现阻塞系统调用(系统调用存在于内核态)，比如当出现缺页错误的时候，会把该线程所在的整个进程中断掉
	不可能使用轮转调度的方式调度线程，换句话说就是多个线程只能一个个按顺序执行
```

* 在内核空间中实现线程

<img src=".\images\image-20240209162820380.png" alt="image-20240209162820380" style="zoom:50%;" />

```
在内核实现不需要运行时系统，转而将线程表放置内核，由内核来管理线程的运行过程

优势：
	可以进行阻塞系统调用
弊端：
	消耗太大(线程的创建，销毁等等)，为了防止消耗过大，对其进行了优化，比如销毁线程的时候并不是真正销毁，而是将其变为不可执行的线程，创建线程也不是真正的创建，而是将不可执行的线程变为可执行
```

* 在用户和内核空间中混合实现线程

<img src=".\images\image-20240209163658072.png" alt="image-20240209163658072" style="zoom:50%;" />

## 进程间通信

* 一个进程如何传递消息给其他进程
* 如何确保两个或多个线程之间不会相互干扰。例如，两个航空公司都试图为不同的顾客抢购飞机上的最后一个座位
* 第三个问题是数据的先后顺序问题，如果进程A产生数据并且进程B打印数据。则进程B打印数据之前需要先等待A产生数据之后才能打印

以后台打印程序为例：

一个后台打印程序。当一个进程需要打印某个文件时，它会将文件名放在一个特殊的后台目录中。另一个进程会定期的检查是否需要文件被打印，如果有，就打印并将该文件名从目录下删除

<img src=".\images\image-20240210145843154.png" alt="image-20240210145843154" style="zoom:50%;" />

### 竟态条件

类似于刚刚的情况，即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竟态条件

如何解决？

禁止一个或多个进程**在同一时刻**对共享资源（包括共享内存，共享文件等）进行读写

### 临界区

临界区是对共享区域进行访问的程序片段

* 任何时候两个进程不能同时处于临界区
* 不应对CPU的速度和数量做任何假设
* 位于临界区外的进程不得阻塞其他进程
* 不能使任何进程无限等待进入临界区

<img src=".\images\image-20240210152728599.png" alt="image-20240210152728599" style="zoom:50%;" />

### 忙等互斥

* 屏蔽中断
* 锁变量
* 严格轮询法
* Peterson算法
* TSL指令

#### 屏蔽中断(适合内核)

在单处理器系统上，最简单的解决方案是让每个进程在进入临界区后立即屏蔽所有中断

对于用户进程来说，屏蔽中断不适合，比如打开着QQ音乐，浏览器等，有其中一个进程进入临界区，其他所有进程都被中断，显然不可以

对内核来说，当它在执行更新或列表的几条指令期间屏蔽中断是很方便的 

#### 锁变量(适合用户空间)

锁变量是寻找一种软件层面的解决方案，是用户可编程性的解决方案

<img src=".\images\image-20240210154903887.png" alt="image-20240210154903887" style="zoom:50%;" />

锁变量也会出现竟态条件

<img src=".\images\image-20240210155202463.png" alt="image-20240210155202463" style="zoom:40%;" />

进程A还没有来得及更新锁变量，进程B就进行判断了

#### 严格轮询法

```c++
/* 进程0 */
while(true){		
    while(trun == 0){		//忙等待
        /* 进入临界区 */
        critical_region();
        turn=1;
        /* 离开临界区 */
        noncritical_region();
    }
}

/* 进程1 */
while(true){
    while(trun == 1){		//忙等待
        /* 进入临界区 */
        critical_region();
        turn=0;
        /* 离开临界区 */
        noncritical_region();
    }
}
```

严格轮询法在某种程度上确实可以视为一种检查锁变量是否被其他线程持有的方式。在这种方法中，线程会通过不断地检查某个标志位或变量的状态来判断是否可以进入临界区，这个标志位或变量可以被看作是一种锁变量。

严格轮询法的主要问题在于它会导致 CPU 资源的浪费，因为线程会不断地进行轮询，而不是在无法立即进入临界区时进行合理的等待。相比之下，互斥锁可以让线程在无法立即获得资源时进入阻塞状态，从而释放 CPU 给其他线程使用，降低了 CPU 资源的消耗。

只有在确定等待时间非常短的时候才使用忙等待

#### Peterson算法

```c++
#define N 2 //进程数量  两个进程 进程号分别为 0和1
int turn; //现在轮到谁了

int interested[N];

void enter_region(int process){	//进入临界区
    int other = 1 - process; //另一个进程号
    interested[process] = true;
    turn = process;
    //以上操作是进程进入临界区之前，初始化interested数组
    
    //空循环
    while(trun == process && interested[other] == true){}
    
    //进入临界区以后的操作
    //......
}

void leave_region(int process){	//离开临界区
    interested[process] = false;
}
```

#### TSL指令(硬件层面)

* 测试并加锁

  TSL RX,LOCK		执行TSL指令的CPU将会锁住内存总线，用来禁止其他CPU在这个指令结束之前访问内存

* 锁住内存总线和禁用中断不一样

<img src=".\images\image-20240210165541534.png" alt="image-20240210165541534" style="zoom:67%;" />

### 优先级反转问题

H进程（优先级高）和L进程（优先级低）两个进程，L进程运行到了临界区，此时H进程进入就绪态，那么CPU就会去调度H进程进入运行态，并且不在调度其他进程，此时H进程进入不了临界区，L进程出不了临界区    

## 消费者与生产者问题

### 睡眠与唤醒

* 忙等待本质：先检查是否能进入临界区，若不允许，则该进程将原地等待，直到允许为止
* 为了不允许它们进入关键区域之前会阻塞而不是浪费CPU时间，最简单的是sleep和wakeup
* Sleep是一个能够造成调用者阻塞的系统调用，也就是说，这个系统调用会暂停，直到其他进程唤醒它。wakeup调用有一个参数，即要唤醒的进程。

### 生产者-消费者问题

两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，将信息放入缓冲区；另一个是消费者，从缓冲区中取出。

缓冲区满---->生产者睡眠，消费者唤醒

缓冲区空---->消费者睡眠，生产者唤醒

如何判断缓冲区为空为满---->设置变量

```c++
/*缓冲区 slot槽的数量*/
#define N 100
/*监视变量 缓冲区数据的数量*/
int count = 0;

//生产者
void producer(){
    int item;
    while(true){
        //生产数据
        item = produce_item();
        if(count == N)
            sleep();	//缓冲区满 生产者睡眠
        //将数据放入缓冲区
        insert_item(item);
        //缓冲区数量+1
        count = count + 1;
        if(count == 1)
            wakeup(consumer);	//消费者唤醒
    }
}

void consumer(){
    int item;
    while(true){
        if(count == 0)
            sleep();	//缓冲区空 消费者睡眠
        //从缓冲区取数据
        item = remove_item();
        //缓冲区数量-1
        count = count - 1;
        if(count == N-1)
            wakeup(producer);	//生产者唤醒
    }
}
```

**问题**：

生产者提前发送信号，但消费者还没来得及准备好接收信号，导致信号丢失

消费者提前进入等待状态，消费者可能会错过生产者发送的信号，导致信号丢失，一直等待，

#### 方法1 监视变量

再设置一个监视变量 wakeup_count=0;  当wakeup信号发送给没有在睡眠的进程 等待位置为1，进程尝试睡眠时，如果检测到为1，则清楚为0

#### 方法2信号量

信号量：累计唤醒的次数

使用一个整型变量来累计唤醒次数，以供之后使用

一个信号量的取值可以是0，或任意正数。0表示的是不需要任何唤醒，任意的正数表示唤醒次数

信号量有两个操作：

​	Down：检测信号量是否大于0，如果大于0，信号量减一，如果等于0，进程睡眠

​	Up：增加信号量

```c++
/*缓冲区 slot槽的数量*/
#define N 100
typedef int semaphore;

semaphore mutex = 1; //控制关键区域访问  mutex为1可以进入  mutex为0不可以进入
semaphore empty = N; //统计缓冲区中空槽的数量
semaphore full = 0; //统计缓冲区满槽的数量

/*监视变量 缓冲区数据的数量*/
int count = 0;

/*
down操作会先检查是否大于0
如果是0，就睡眠
此时down操作会一直检测执行

up操作会使信号量加一

信号量的增加唤醒和为0睡眠是不可分割的，就不会有某个进程因为执行了up操作而阻塞
*/

/*
对于一个中断而言
1.硬件压入堆栈程序计数器
2.从中断向量装入新的程序计数器
3.保存寄存器的值
4.设置新的堆栈
5.中断服务器运行
6.调度器来决定哪个程序先执行
7.返回到汇编代码
8.汇编语言开始执行新的程序
*/

//生产者
void producer(){
    int item;
    while(true){
        //生产数据
        item = produce_item();
        //空槽数量减1	如果空槽数量为0，即槽位全满，生产者睡眠，否则唤醒
        down(&empty);
        //进入关键区域
        down(&mutex);	//如果此时mutex为0,说明消费者在关键区，生产者无法进入
        //将数据放入缓冲区
        insert_item(item);
        //离开关键区域
        up(&mutex);
        //满槽数量加一
        up(&full);
    }
}

void consumer(){
    int item;
    while(true){
        //满槽数量减一  如果满槽为0，即槽位全空，消费者睡眠，否则唤醒
        down(&full);
        //进入关键区域
        down(&mutex);	//如果此时mutex为0,说明生产者在关键区，消费者无法进入
        //从缓冲区取数据
        item = remove_item();
        //离开关键区
        up(&mutex);
        //空槽数量加一
        up(&empty);
        //缓冲区数量-1
        count = count - 1;
        if(count == N-1)
            wakeup(producer);	//生产者唤醒
    }
}
```

## 互斥量_管程

### FUTEXES

同步+互斥 ===》Futex

* 内核服务
* 用户库

<img src=".\images\image-20240212151002155.png" alt="image-20240212151002155" style="zoom:33%;" />

### PTHREADS中的互斥量

| 线程调用              | 描述                   |
| :-------------------- | ---------------------- |
| Pthread_mutex_init    | 创建一个互斥量         |
| Pthread_mutex_destroy | 撤销一个已存在的互斥量 |
| Pthread_mutex_lock    | 获得一个锁或阻塞       |
| Pthread_mutex_trylock | 获得一个锁或失败       |
| Pthread_mutex_unlock  | 释放一个锁             |

### 条件变量

在生产者消费者问题中

首先，一个线程将东西放入缓冲区，另一个线程取出，如果生产者发现缓冲区没有空槽位，生产者阻塞，直到有空槽位可以使用，使用mutex主要为了进行原子性的检查，目的是为了不受其他的线程干扰，当发现满了以后，需要一种方法来阻塞自己并且在以后可以被唤醒

| 线程调用               | 描述                             |
| ---------------------- | -------------------------------- |
| Pthread_cond_init      | 创建一个条件变量                 |
| Pthread_cond_destory   | 销毁一个条件变量                 |
| Pthread_cond_wait      | 阻塞以等待一个信号               |
| Pthread_cond_signal    | 向另一个线程发信号来唤醒它       |
| Pthread_cond_broadcast | 向多个线程发信号来让它们全部唤醒 |

### 互斥量+条件变量

```c++
#include <stdio.h>
#include <pthread.h>
//互斥量和条件变量

/* 生产的数量 */
#define MAX 1000000
//mutex信号量
pthread_mutex_t the_mutex;
//使用信号量(满槽和空槽的数量)
pthread_cond_t condc,condp;

//缓冲区
int buffer = 0;

/* 生产数据 */
void producer(void* ptr){
	for(int i=0; i <= MAX; i++){
        //临界区需要独占 使用mutex获取锁
        pthread_mutex_lock(&the_mutex);
        while(buffer != 0){
            pthread_cond_wait(&condp,&the_mutex);
        }
        //把他们放入到缓冲区
        buffer = i;
        /* 唤醒消费者 */
        pthread_cond_signal(&condc);
        //释放缓冲区
        pthread_mutex_unlock(&the_mutex);
    }
    pthread_exit(0);
}

/* 消费数据 */
void consumer(void* ptr){
	for(int i=0; i <= MAX; i++){
        //临界区需要独占 使用mutex获取锁
        pthread_mutex_lock(&the_mutex);
        while(buffer == 0){
            pthread_cond_wait(&condc,&the_mutex);
        }
        //从缓冲区读取数据
        item = buffer;
        /* 唤醒生产者 */
        pthread_cond_signal(&condp);
        //释放缓冲区
        pthread_mutex_unlock(&the_mutex);
    }
    pthread_exit(0);
}
```

### 管程

管程是程序，变量和数据结构等组成的一个集合，它们组成一个特殊的模块或者包

管程有一个很重要的特性，即在任何时候管程中**只能有一个活跃的进程**，这一特性使管程能够很方便的实现互斥操作（编译器负责）

```c++
public class ProducerConsumer {
    
    static final int N = 100; //定义缓冲区数组的长度
    //初始化一个生产者 一个消费者 一个管程
    static Producer p = new Producer();
    static consumer c = new consumer();
    static Our_monitor mon = new Our_monitor();
    //生产者代码		run里面包含了各种线程要执行的代码
    static class Producer extends Thread{
        @Override
        public void run(){
            int item;
            //生产者循环
            while(true){
                item = produce_item();
                mon.insert(item);
            }
        }
        //生产数据的代码
        private int produce_item(){
            //......
        }
    }
    
    //消费者代码		run里面包含了各种线程要执行的代码
    static class consumer extends Thread{
        @Override
        public void run(){
            int item;
            //消费者循环
            while(true){
                item = mon.remove();
                //运行消费者代码
                consumer_item();
            }
        }
         //生产数据的代码
        private void consumer_item(){
            //......
        }
    }
    
    
    //管程
    static class Our_monitor {
        private int buffer[] = new int[N];
        //记数器和索引
        private int count = 0,lo = 0,hi = 0;
        
        private synchronized void insert(int val){
            if(count == N){
                //如果缓冲区满了	休眠
                go_to_sleep();
            }
            //向缓冲区插入数据
            buffer[hi] = val;
            hi = (hi+1)%N;
            count = count+1;
            
            if(count == 1){
                notify();
            }
        }
        
        private synchronized void remove(int val){
            int val;
            if(count == 0){
                go_to_sleep();
            }
            //从缓冲区取数据
            val = buffer[lo];
            lo = (lo+1)%N;
            count = count - 1;
            if(count == N-1){
                notify();
            }
        }
        
        private void go_to_sleep(){
            wait();
        }
    }
}
```

## 消息屏障 屏蔽 RCU算法

### 消息传递

```
send(destination,&message);
receive(source,&message);
```

### 消息传递的设计要点

<img src=".\images\image-20240214151924429.png" alt="image-20240214151924429" style="zoom:50%;" />

如何判断重复发送的信息？序号

如何命名进程(发送给谁发，接收从哪接)

```c++
#include <pthread.h>

//定义buffer中槽的数量
#define N 100;

//假设所有消息都有相同的大小，并且还有接受到发出的消息的时候，操作系统自动进行缓冲

void producer(){
    int item;
    message msg; //消息传递的内容
    
    while(true){
        item = produce_item();//生产者生产即将放入缓冲区的数据
        //等待消费者来发送空的缓冲区的消息
        receive(consumer, &msg);
        //等待完成，建立待发送的消息
        build_message(&msg, item);
        /* 发送给消费者 */
        send(consumer,&msg);
    }
}

void consumer(){
    int item;
    message msg; //消息传递的内容
    
    for(int i=0;i<N;i++){
        //给生产者发送N个缓冲区
        send(producer,&msg);
    }
    
    while(true){
        //接受包含数据的消息
        receive(producer,&msg);
        //将数据从消息系统中提取出来
        item = extract_item(&message);
        //再把空的缓冲区发送给生产者
        send(producer,&message);
        //对数据进行处理
        //......
	}
}
```

### 屏障

屏障用于进程组

某些应用中划分了若干阶段，并且规定，**除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段**

<img src=".\images\image-20240214160008687.png" alt="image-20240214160008687" style="zoom:50%;" />

屏障不是来用于互斥，是用来和条件变量类似的协同

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <pthread.h>

//设置屏障总数(组织多少个进程)
#define PTHREAD_BARRIER_SIZE 4
//定义一个屏障
pthread_barrier_t barrier;

void err_exit(const char* err_msg){
    exit(1);
}

void* thread_fun(void* arg){
    int result;
    char* thr_name = (char*)arg;
    cout<<"线程"<<thr_name<<"工作完成"<<endl;
    //等待屏障
    result = pthread_barrier_wait(&barrier);
    if(result == PTHREAD_BARRIER_SERIAL_THREAD){
        cout<<"线程"<<thr_name<<"wait后第一个返回"<<endl;
	}
    else if(result == 0){
        cout<<"线程"<<thr_name<<"返回后为0"<<endl;
    }
    return NULL;
}

int main(){
    
    pthread_t tid_1,tid_2,tid_3;
    int result;
    //初始化屏障
    pthread_barrier_init(&barrier,NULL,PTHREAD_BARRIER_SIZE);
    
    if(pthread_create(&tid_1,NULL,thread_fun,"1") != 0){
        err_exit("create thread 1");
    }
    if(pthread_create(&tid_2,NULL,thread_fun,"2") != 0){
        err_exit("create thread 2");
    }
    if(pthread_create(&tid_3,NULL,thread_fun,"3") != 0){
        err_exit("create thread 3");
    }
    
    //主线程等待工作完成
    result = pthread_barrier_wait(&barrier);
    cout<<"所有的工作已完成"<<endl;
    
    if(result == PTHREAD_BARRIER_SERIAL_THREAD){
        cout<<"主线程"<<thr_name<<"wait后第一个返回"<<endl;
	}
    else if(result == 0){
        cout<<"主线程"<<thr_name<<"wait返回后为0"<<endl;
    }
    
    return 0;
}
```

### 避免锁

避免锁就是不使用任何锁（**读操作**）

在某些情况下，我们可以允许写操作来更新数据结构，即便还有其他的进程正在使用

**确保每个读操作要么读取旧的版本，要么读取新的版本**

<img src=".\images\image-20240214174330372.png" alt="image-20240214174330372" style="zoom:50%;" />



![image-20240214174425707](.\images\image-20240214174425707.png)



## 操作系统进程与线程的调度

### 调度的介绍

当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争CPU时间片

当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况，如果只有一个CPU可用，那么必须选择接下来哪个进程/线程可以运行

操作系统中有一个叫做 **调度程序** 的角色存在，它就是做这件事情的，该程序使用的算法叫做 **调度算法**

### 进程行为

<img src=".\images\image-20240215115741469.png" alt="image-20240215115741469" style="zoom:50%;" />

根据进程占用CPU时间的长短，划分为两种进程

* CPU密集型进程（a） 适合多进程

一般是指服务器硬盘，内存硬件的性能相对CPU好很多，或者使用率低很多。系统运行CPU读写I/O时可以在很短的时间内完成，几乎没有阻塞时间，而CPU一直有大量运算要处理，因此CPU负载长期过高

* I/O密集型进程（b）适合多线程

一般是指服务器CPU的性能相对硬盘，内存硬件好很多，或者使用率低很多。系统运行多是CPU在等I/O的读写操作，此类情景下CPU负载并不高

### 何时调度？

第一个和调度有关的问题是何时调度决策。存在着需要调度处理的各种情形。首先，在创建一个新进程后，需要决定是运行父进程还是子进程

第二，在进程退出时需要做出调度决定。因此此进程不再运行，转而必须从就绪进程中选择其他进程运行（空闲进程）

第三种情况是，当进程阻塞在I/O，信号量或其他原因时，必须选择另外一个进程来运行

第四点，当I/O中断发生时，可以做出调度决策 

### 调度算法的分类

根据如何处理**时钟中断**可以把调度算法分为两类

* 非抢占式

  挑选一个进程，让该进程运行直到被阻塞（阻塞在I/O上或等待另一个进程）或者直到该进程自动释放CPU

* 抢占式

  选择一个进程，并使其在最大固定时间内运行。如果在时间间隔结束后仍在运行，这个进程会被挂起，调度程序会选择其他进程(就绪态)来运行

### 调度系统的环境

* 批处理系统

  广泛应用于商业领域（工资单，报账等），使用非抢占式调度算法，进程一个个进行执行，如果使用抢占式，需要时钟周期，并且周期较长

* 交互式系统

  避免一个进程霸占CPU，必须使用抢占式调度算法

* 实时系统

  推进现有应用程序

### 调度算法的目标

对于所有系统，都要公平，平衡，策略强制执行

**公平**：对所有进程分配的CPU时间片要尽量公平

**平衡**：平衡CPU密集型进程和I/O密集型进程的分配

**策略强制执行**：CPU给出的命令必须执行



* 批处理系统：

  ​	吞吐量：系统每小时完成的数量（批处理完成的工作量）

  ​	周转时间：从批处理提交开始到完成的平均时间

  ​	CPU利用率

* 交互式系统：

  ​	响应时间：双方交互时的响应时间

  ​	均衡性：（用户感性方面，比如用户在打开一个网页，同时又有一个邮件发来，这时要优先打开网页）

* 实时系统：

  ​	满足截止时间

  ​	可预测性



### 批处理系统中的调度

* 先来先服务

<img src=".\images\image-20240215170851347.png" alt="image-20240215170851347" style="zoom:50%;" />



<img src=".\images\image-20240215170920621.png" alt="image-20240215170920621" style="zoom:50%;" />



<img src=".\images\image-20240215171000911.png" alt="image-20240215171000911" style="zoom:50%;" />

* 最短作业优先

举例来说：一家保险公司，因为每天要做理赔工作，所以人们可以相当精确地预测处理1000个索赔的一批作业需要多长时间

<img src=".\images\image-20240215171325991.png" alt="image-20240215171325991" style="zoom:50%;" />

使用最短作业优先可以缩短周转时间

a：（8+12+16+20）/4 = 14

b：（4+8+12+20）/4 = 11

使用最短作业优先需要保证队列中的进程全是就绪状态

* 最短剩余时间优先

最短作业优先的抢占式版本

如果新加入队列的进程执行时间小于当前执行进程的时间，直接挂起当前进程，优先处理新加入的进程

### 交互式系统的调度

* 轮询调度

<img src=".\images\image-20240216202942809.png" alt="image-20240216202942809" style="zoom:50%;" />

系统会轮流检查每个就绪的任务，逐个地为它们分配处理器时间片

具体来说，轮询调度的工作流程如下：

1. **就绪队列：** 在系统中，有多个任务处于就绪状态，它们都等待着被执行。
2. **轮询过程：** 调度器会按照一定顺序轮流检查就绪队列中的任务，逐个为它们分配处理器时间片。通常情况下，每个任务被分配的时间片长度是相等的。
3. **任务执行：** 当轮到某个任务执行时，它会被分配到处理器资源，并且被允许执行。这个任务会执行一段时间，直到它的时间片用完、发生阻塞（如等待I/O操作完成）或者自愿放弃CPU（如进行等待）。
4. **切换任务：** 当任务的时间片用完或者发生了阻塞，调度器会暂停当前任务的执行，并将处理器分配给下一个就绪的任务。这个过程持续循环，直到所有任务都执行完毕或者没有就绪的任务为止。

问题：一个时间片太长，会导致一个请求会得不到响应；一个时间片太短，会导致切换次数太多，浪费资源



* 优先级调度

轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样的

每个进程都被赋予一个优先级，优先级高的进程优先运行（优先级由程序员分配，空闲进程优先级最低）

调度程序会在每个时钟中断期间降低当前运行进程的优先级

优先级的分配：

​	动态分配

​	静态分配：提前写死，资源降级 

<img src=".\images\image-20240216204857652.png" alt="image-20240216204857652" style="zoom:50%;" />

优先级也不是写死的，还要按照情况进行动态调整（饥饿现象），出现饥饿现象：进行优先级降级

在每个大块儿的优先级后面的进程也不是同等的，也是按照优先级排列，叫做**多级队列**

**多级队列：**该算法将系统中的进程就绪队列从一个拆分成若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，**一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级**



* 最短进程优先

交互式进程通常遵循下列模式：等待命令，执行命令，等待命令，执行命令......

把每一个命令的执行看作分离的作业，那么我们可以通过首先运行最短的作业来使响应时间最短

如何从当前可运行的进程中找出最短的那一个进程？

预测----->通过当前的测量值和之前的估计值进行加权平均，得到下一次的测量值

假设每个终端每条命令的预估时间是T0，测量到下一次运行时间是T1，那么通过加权评估

**aT0+(1-a)T1**



* 保证调度

若用户工作时有n个用户登录，则每个用户将获得CPU处理能力的1/n

前提是保证所有的进程等价



* 彩票调度

彩票，中将和不中奖都是随机的

为进程提供各种系统资源（例如CPU时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。

但这里的彩票和现实的彩票不一样，对于一些较为重要的进程，要人为干预去增加中奖概率

彩票调度可以解决饥饿问题



* 公平分享算法(针对用户)

<img src=".\images\image-20240216213729042.png" alt="image-20240216213729042" style="zoom:50%;" />

无论一个用户运行多少进程，CPU的占比要尽量公平

### 实时系统的调度

在需要实时的情况下，正确但是却缓慢的响应甚至要比没有响应还糟糕

硬实时和软实时系统

​	硬实时：必须严格的满足实时时间

​	软实时：可以容忍稍微的不那么实时

实时系统要求每个进程都是可预测的，寿命较短，并且运行速度极快

在检测到一个外部信号时，调度程序的任务就是按照满足所有截至时间的要求调度进程

### 实时系统中的事件的分类

周期性事件

​	在周期性事件中如何判断是否可以被调度：

<img src=".\images\image-20240216220125418.png" alt="image-20240216220125418" style="zoom:50%;" />

非周期事件

实时系统的调度算法可以是静态的或动态的

​	静态：在开始运行之前，就已经知道调度决策

​	动态：在运行中，选择调度决策，判断在截止时间前能不能完成

## 调度策略和机制

策略和机制是分开来的，在操作系统中各种调度算法的机制是本身存在的，到底进程之间的优先级如何排列，进程竞争的时候如何调度，是由用户来决定的，这叫做策略

## 线程调度

### 用户级线程

<img src=".\images\image-20240217204633556.png" alt="image-20240217204633556" style="zoom:50%;" />

线程的调度运行在运行时系统

### 内核级线程

<img src=".\images\image-20240217205331860.png" alt="image-20240217205331860" style="zoom:50%;" />