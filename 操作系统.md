# 操作系统

## 操作系统总览

### 程序从创建到运行的过程

```c++
#include <stdio.h>
int main(){
    printf("hello world\n");
    return 0;
}
```

任何一个程序的生命周期都是从一个源文件开始的，源文件都是从main函数开始的，电脑上的任何信息都是以二进制的形式去记录的，那么源代码本质上是由0和1组成的一些序列，又将8位看作一个整体作为一个字节，用字节来表示程序中的字符

正是因为所有信息都是由二进制表示的，那么由二进制转为八进制，十进制，十六进制的编码来表示字符，比如ascall码，用这种编码来表示文本字符

#### 程序如何向操作系统迈进的？

将程序变为一个可执行的目标文件，以二进制的形式存入磁盘，就是程序向操作系统迈进的过程，这整个过程都是由编译器完成的，编译器在这个过程中分为了四步

* 预处理过程（生成 .i 文件）

  将我们需要引用的所有内容插入到源文件

  命令：gcc -E hello.c -o hello.i

  <img src=".\images\image-20240201191911893.png" alt="image-20240201191911893" style="zoom: 50%;" />

<img src=".\images\image-20240201191938589.png" alt="image-20240201191938589" style="zoom: 33%;" />

* 编译阶段（生成 .s 文件）

  将预处理过后的.i文件翻译成**汇编程序**，这一阶段**保证了操作系统与机器一对多的性质，因为汇编是所有操作系统都可以识别认证的**，此时不同的语言经过不同的编译器经过一系列过程变成了通用的汇编语言

  命令：gcc -S hello.i -o hello.s

  <img src=".\images\image-20240201192203154.png" alt="image-20240201192203154" style="zoom:50%;" />

<img src=".\images\image-20240201192223060.png" alt="image-20240201192223060" style="zoom:33%;" />

* 汇编阶段（生成 .o 文件）

  **汇编器**将 .s 文件翻译成**机器语言指令**

  命令：gcc -c hello.s -o hello.o

<img src=".\images\image-20240201193225204.png" alt="image-20240201193225204" style="zoom:50%;" />

<img src=".\images\image-20240201193244521.png" alt="image-20240201193244521" style="zoom:50%;" />

* 链接阶段（生成可执行文件）

**链接器**把需要调用的一些标准库文件(其他的目标文件)链接到文本文件当中，最终结果是得到一个可执行文件，然后加载到内存中，交给操作系统去执行

### 操作系统是如何区分和识别代码的

像一篇文章一样，要知道人物的心理是需要上下文的，操作系统也一样，也是通**过所谓的上下文来区分代码**，对于所有的程序，是只有上文，没有下文的

### 计算机常见硬件

处理器，内存，键盘，鼠标，显示器，网络接口，打印机等等所有的硬件在操作系统中都有对应的映射，除了像鼠标键盘这种I/O设备，程序员不会直接和硬件打交道，都会在硬件中封装一层软件，而这个软件就是**操作系统**，说白了，**操作系统就是建立一个和计算机硬件一一对应的计算机模型**

<img src=".\images\image-20240201201328871.png" alt="image-20240201201328871" style="zoom:50%;" />

操作系统是运行在内核态的，内核态其实就是操作系统的一种运行状态，操作系统是有硬件的访问权的，是可以执行机器中能够运行的任何指令；软件的其余部分全部运行在用户态，对接应用程序的一些接口，越靠近用户态上级的地方越容易编写；操作系统的主要目的是保护硬件



<img src=".\images\image-20240201202010013.png" alt="image-20240201202010013" style="zoom:50%;" />

​																							        简单个人计算机的组件

根据这个简单的个人计算机的组件可以抽象出最经典的系统硬件组成的模型

<img src=".\images\image-20240201202249116.png" alt="image-20240201202249116" style="zoom:50%;" />

* CPU：中央处理单元，处理和执行一些指令，计算机的大脑，处理的指令是从内存来的，任何时候CPU都是通过地址指向主存中的机器指令。
* 寄存器(PC)
  * 程序计数器：CPU不是直接与主存进行交互的，是通过程序计数器(寄存器)与主存交互的，程序计数器(寄存器)中存储指向下一条指令的地址
  * 通用寄存器：CPU从内存中获取指令的时间要远远大于CPU执行一条指令的时间，这个时候，寄存器会保存上一条指令执行的结果，程序记数器是通用寄存器的一环，通用寄存器还可以保存堆栈指针
  * 程序状态寄存器：跟踪当前系统的状态，在系统调用和输入输出起着关键作用

回到CPU，刚刚说到的内核态和用户态都存在于CPU中，通过程序状态寄存器中的一个二进制位可以控制CPU的状态是内核态还是用户态，当运行在内核态中，CPU可以执行指令集中的任何指令，并且可以使用硬件，如果运行在用户态中，有很多指令是被禁止的，比如内存保护相关指令，所以在这种状态下如何使用这些指令呢，那就需要用到用户接口程序来调用系统服务，所以用户接口程序就是转换内核态

### 取指单元,解码单元,执行单元

传统的CPU是读取指令，解码指令，执行指令三个环节一一执行，但是现代CPU是把三部分分开独立起来，在一个CPU中分为取指单元，解码单元，执行单元，为的是提高性能

**超标量流水线**：多个取指单元同时读取指令，进行解码，然后放到缓冲区，紧接着后面哪个执行单元空了就放到哪个单元，这种形式更偏向于无序的情况

<img src=".\images\image-20240201211616578.png" alt="image-20240201211616578" style="zoom:50%;" />

### 内存

内存的理想状态是存储空间又大，价格又便宜，而且让CPU读取信息又快，但是以目前的技术手段实现不了，就对内存进行了分层

<img src=".\images\image-20240201214220585.png" alt="image-20240201214220585" style="zoom:50%;" />

* 高速缓存：由硬件控制，是由主存分割出来的高速缓存行，高速缓存会检查需要的高速缓存行是否存在于高速缓存行中，因为寄存器和主存的访问时间相差还是很大的，而且CPU执行指令的时间远远快于从寄存器中读取指令的时间，高速缓存是在主存和寄存器之间做的缓存，就是为了提高寄存器读取指令的效率

  * 什么时候把新的内容存放进缓存？
  * 新的内容存在在缓存的哪一行？
  * 当我们需要新的空间作为缓存，应该移除哪块内容？
  * 移除的内容放在哪？

  由这四个问题引申出许多种缓存系统，在现代CPU种，主要有两种缓存

  * 第一级放在CPU内部，用来将已经解码的指令调入CPU的执行引擎
  * 第二种缓存，用来存放最近使用的关键字

* 主存：

  * RAM（随机访问存储器）
    * RAM是一种易失性存储器，这意味着当断电时，其中存储的数据会丢失。
    * RAM允许计算机随机地读取或写入数据，因此称为“随机存取存储器”。
    * RAM通常用于存储正在运行的程序和临时数据，包括操作系统和应用程序。
    * RAM的速度很快，但容量相对较小，且数据不持久。
  * ROM（只读存储器）
    * ROM是一种非易失性存储器，这意味着其中存储的数据不会因为断电而丢失。
    * ROM的内容在制造时被预先设定，并且一般情况下无法修改，因此称为“只读存储器”。
    * ROM用于存储固定的程序和数据，如计算机的基本引导程序（Bootstrap Loader）和固件（Firmware）等。
    * ROM通常用于存储一些需要在计算机启动时立即访问的数据和指令。

* 磁盘：访问速度慢，保存文件信息

  * 磁盘访问慢的原因是磁盘的构造（寻道时间，磁盘碎片化等等）

  <img src=".\images\image-20240202150516179.png" alt="image-20240202150516179" style="zoom:50%;" />

<img src=".\images\image-20240202150658014.png" alt="image-20240202150658014" style="zoom:50%;" />

<img src=".\images\image-20240202150803214.png" alt="image-20240202150803214" style="zoom:50%;" />

内存访问速度很快，但是成本大，存储空间小，使用很多的内存意味着消耗的成本很昂贵，所以就需要存储空间很大的磁盘来充当内存，但是磁盘的访问速度很慢，那么如何解决访问速度不匹配的问题呢？解决方法就是利用缓存，在磁盘中做了内存地址的映像，把经常访问的地址映射到主存，使其提高访问速度

### I/O设备

I/O设备主要分两大类，一类是我们可以看得到的设备，比如键盘鼠标，打印机，显示器等，另一类是一些控制器，USB控制器，硬盘控制器，这些控制器就是一个个小芯片，这些控制器对于I/O设备来说就是操作系统，目的是为了屏蔽各种物理细节

实现输入和输出的方式有三种：

* 忙等待

  当一个设备要输入的时候，操作系统将输入的控制权交给该设备，该设备去占据CPU，其他的输入设备只能等待，当该设备工作完成，再将CPU的控制权交还给调用者

* 中断

  中断是为了解决忙等待的问题，在忙等待中，当一个设备正在执行输入输出操作时，操作系统或应用程序需要不断地轮询设备状态，从而导致 CPU 被长时间占用。而中断机制允许设备在需要时发送中断请求，CPU 可以继续执行其他任务，直到设备就绪并触发中断。

  <img src=".\images\image-20240202161636854.png" alt="image-20240202161636854" style="zoom:50%;" />

  一开始磁盘驱动器会在CPU中下一个驱动

  1:CPU告诉磁盘控制器，磁盘可以开始工作了

  2：发送中断信号到中断控制器，信号的接受与否看该信号的优先级

  3 4: 中断控制器接收信号，将信号传给CPU，CPU执行中断信号，此时会记录被中断设备在结   		束运行时的一些信息和地址，这些信息会保存到被中断设备的寄存器中，然后CPU瞬间切		换到内核态 

* 直接存储器访问（DMA）

### 将设备驱动器装入操作系统

* 第一个途径是将内核与设备启动程序重新连接，然后重启系统
* 第二个途径是在一个操作系统文件中设置一个入口，通知该文件需要一个设备驱动程序，然后重新启动系统。在重启系统时，操作系统会寻找有关的设备启动程序并把它装载
* 第三个途径是操作系统能够在运行时接收新的设备驱动程序并立刻安装，无需重启操作系统

### 总线(BUS)

* 总线就跟公共汽车一样
* 公共汽车的站点----------多个设备或者接入点
* 乘客------------传输的数据包
* 车是有容量的，所以传输的信息也是有容量的---------字节块
* 车辆谁先走，谁后走，走哪站，需要有顺序，有规定----------控制器 

<img src=".\images\image-20240202165745634.png" alt="image-20240202165745634" style="zoom:50%;" />

### **硬件支持系统，系统管理硬件**

* 操作系统其实就是一个建立在应用程序和硬件之间的一道桥梁
* 基本功能：
  * 防止硬件被滥用
  * 通过一种比较简单的机制匹配对应的应用程序，进而控制复杂的硬件
* 对硬件进行抽象
  * 进程(处理器，主存，I/O设备)
  * 虚拟内存(主存和磁盘)
  * 文件(I/O设备)

#### 进程

* 进程的本质就是操作系统执行的一个程序

* 与进程相关

  * **地址空间------存放的是可执行程序**
  * **资源集-------通常包括寄存器，打开文件的清单，突发的报警，有关的进程清单和其他需要执行程序的信息**

  

  假设一种场景

  ​	用户启动一个视频剪辑程序，指示它按照某种格式转换视频，然后去浏览网页，同时，一个	检查电子邮件的后台进程被唤醒并开始运行

  ​	这是三个独立的活跃进程，CPU不是同时执行这三个进程，而是不断轮换，挂起一个进程，执行一个进程，只不过是轮换的时间非常快，在切换的时候，也叫做中断，**在挂起一个进程转而执行另一个进程的时候，会将挂起进程当前的所有状态信息保存在操作系统的进程表中**

  

  进程挂起包括：

* 进程的地址空间----磁盘映像

* 进程表项（进程当前的所有状态信息存储在进程表中）

  与进程管理有关的最关键的系统调用往往是决定着进程的创建和终止的系统调用

  

  进程间通信

* 合作完成某些作业的相关进程经常需要彼此通信来完成

* 那么信息丢失怎么办？

  * 利用定时器来防止信息丢失，当进程A给进程B发送信息后，定时器开始启动，在若干秒后，操作系统会向进程B发送一个确认通知，如果进程B没收到刚刚信息，操作系统会向进程A发送警告，然后进程A重新发送信息，在等待确认的过程中进程A会被挂起 

#### 线程

* 线程是操作系统能够运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位
* 为什么会有线程的概念？
  * 进程的颗粒度太大，线程主要共享的是进程的地址空间，进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同

#### 地址空间

在一个非常简单的操作系统中，仅仅有一个应用程序运行在内存中，为了运行第二个应用程序，需要把第一个应用程序移除才能把第二个程序装入内存

复杂一些的操作系统会允许多个应用程序同时装入内存中运行，为了防止应用程序之间相互干扰，就引出了地址空间，每个程序都有属于自己的地址空间

#### 虚拟内存

进程直接访问物理地址会带来不可预估的风险

物理内存资源是宝贵且非常有限

内存分配时，连续内存分配会产生很多难以分配的内存碎片

为了避免这些问题，从而引出了虚拟内存

虚拟内存是一种解决方案，用于解决计算机系统中的内存管理和资源限制问题

1. **扩大可用内存空间**：虚拟内存允许程序使用比物理内存更大的地址空间，因为它可以使用硬盘空间作为临时的扩展内存。
2. **提高系统的响应速度和效率**：通过将不活跃的内存页面存储到硬盘上，并在需要时将其重新加载到物理内存中，虚拟内存能够优化内存的使用，提高系统的整体性能和响应速度。

形象理解：

想象你有一个小房子（代表你的计算机的物理内存），这个房子有一定的空间，但是不够大。现在你想装入很多家具（代表程序和数据），但是家具太多，无法一次性全部放进房子里。

虚拟内存就好像你在房子外面有一个储藏室（代表硬盘），你可以把一部分不经常使用的家具放到储藏室里。当你需要某件家具时，你可以把它从储藏室取出放到房子里使用，同时可以把另一件不需要的家具放回储藏室。这样，你的房子看起来就好像有很大的空间一样，虽然实际上你只是用了有限的房间和储藏室。

这个例子中：

- 房子就是物理内存，有限的、可见的内存空间。
- 储藏室就是硬盘，无限的、不可见的存储空间。
- 家具就是程序和数据，需要被存储和使用。

虚拟内存的作用就是扩大了你可用的内存空间，使得你能够运行更多的程序和处理更多的数据，而不受物理内存大小的限制。

#### 文件

几乎所有操作系统都支持的另一个关键概念就是文件系统

对文件的所有操作几乎全部需要系统调用

操作系统的一项主要功能是屏蔽磁盘和其他I/O设备的细节特性，给程序员提供一个良好，清晰的独立于设备的抽象文件模型

保存文件的地址：目录

<img src=".\images\image-20240203145514627.png" alt="image-20240203145514627" style="zoom:50%;" />

#### 管道

是一种虚文件，用来连接两个进程

<img src=".\images\image-20240203150428747.png" alt="image-20240203150428747" style="zoom:50%;" />

#### 并发和并行

并发和并行是既相似又有区别的两个概念

​	并行是指两个或者多个事件在同一时刻发生

​	并发是指两个或多个事件在同一时间段内交替发生

#### 系统调用

操作系统提供两种功能

​	为用户提供应用程序抽象

​	管理计算机资源

只有系统调用能进入内核态，操作硬件

<img src=".\images\image-20240203152103526.png" alt="image-20240203152103526" style="zoom:50%;" />

假如现在是一个读文件的C语言代码

1 2 3：传入读取文件相关的参数

4：调用函数

5：调用之后，把代码进行分区放置到虚拟内存（因为是临时数据）

6：进入内核态

7 8：内核态中执行系统调用

9：返回给用户

系统调用的分类：

* 用于进程管理的系统调用

* 用于文件管理的系统调用
* 用于目录管理的系统调用

#### 操作系统结构

* 单体结构(最常用)

  单体结构和我们平时写的代码一样，是以单一的程序来进行运行的

  优点：调用任何一个所需要的程序都非常高效

  缺点：成千上万的调用显得臃肿，笨拙，只要系统发生故障，任何程序将不可用，这往往是灾			难性的

<img src=".\images\image-20240203153411362.png" alt="image-20240203153411362" style="zoom:50%;" />

* 分层系统

  利用层级来分隔不同的功能，分层结构中的所有功能都存放于内核态中

* 微内核

  传统上，所有层都在内核中，但是这样做没有必要

  尽可能减少内核态中功能可能是更好的做法

  只有一个模块----微内核------运行在内核态，其余模块可以作为普通用户进程运行在用户态

  <img src=".\images\image-20240203154053721.png" alt="image-20240203154053721" style="zoom:50%;" />

  

* 客户-服务端系统

<img src=".\images\image-20240203154230152.png" alt="image-20240203154230152" style="zoom:50%;" />

## 进程

在操作系统中，进程是指计算机中正在运行的程序的实例。一个进程包括了程序的执行代码、数据和所需的系统资源，例如内存、CPU时间、文件和设备等。每个进程都被操作系统视为独立的实体，拥有自己的地址空间和执行环境。进程之间可以相互通信和交互，但彼此之间是相互独立的，通常由操作系统进行调度和管理。

<img src=".\images\image-20240203183823310.png" alt="image-20240203183823310" style="zoom:40%;" />

### 支持多进程的多道程序系统

严格意义来说，在某一瞬间，CPU只能运行一个进程

* 伪并行：

  伪并行是指单核或多核处理器同时执行多个进程，从而使程序更快

因为CPU执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪

### 进程模型

<img src=".\images\image-20240207174625669.png" alt="image-20240207174625669" style="zoom:50%;" />



<img src=".\images\image-20240207175447155.png" alt="image-20240207175447155" style="zoom:50%;" />



<img src=".\images\image-20240207175523708.png" alt="image-20240207175523708" style="zoom:50%;" />

### 进程的创建

* 系统初始化
* 正在运行的程序执行了创建进程的系统调用
* 用户请求创建一个新进程
* 初始化一个批处理工作

#### 系统初始化

启动操作系统时，系统通常会自动创建若干个进程

分类：

​	前台进程：可以和用户做交互

​	守护进程：一般处于休眠状态（比如后台邮件接收进程）

#### 系统调用创建

除了在启动阶段创建进程之外，一些新的进程也可以在后面创建。通常一个正在运行的进程会发出系统调用来创建一个或多个新进程来帮助其完成工作

#### 用户请求创建

输入一个命令或者双击图标打开的一个程序

#### 批处理创建

批处理创建是指一次性创建多个进程的过程。通常情况下，批处理创建用于批量处理任务，例如在批处理文件中列出一系列需要执行的命令或程序，然后一次性执行这些命令或程序，从而创建多个进程并同时运行它们。

### 进程的终止

* 正常退出(自愿的)
* 错误退出(自愿的)
* 严重退出(非自愿的)
* 被其他进程杀死(非自愿的)

### 进程的层次结构

**UNIX进程体系**

<img src=".\images\image-20240207192617408.png" alt="image-20240207192617408" style="zoom:50%;" />

**Windows进程体系**

Windows中没有进程层次的概念，Windows中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌(成为句柄)，该句柄可以用来控制子进程

### 进程的状态

尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助

<img src=".\images\image-20240207193540410.png" alt="image-20240207193540410" style="zoom:50%;" />

1：等待输入而阻塞

2：调度程序根据优先级选择一个程序，将其从运行状态变为就绪态

3：调度程序根据优先级选择一个程序，将其从就绪状态变为运行态

4：执行有效的输入后，阻塞态变为就绪态

```shell
cat chapter1 chapter2 chapter3 | grep tree

grep tree执行完后进入阻塞状态，等待有效的输入，cat chapter1 chapter2 chapter3执行完后对grep tree进行了有效输入，进程从阻塞态变为就绪态，如果此时没有其他的进程执行或者说该进程优先级足够高，调度程序会选择将其从就绪态变为运行态进行运行
```

阻塞态是我必须等外部的某个事件发生以后我才能运行，否则我不能运行

就绪态是我本身已经可以运行了，但是由于有一些其他优先级较高于自己的进程正在运行，我不能运行

## 线程

为什么要在进程的基础上再创建一个线程 

* 多线程之间会**共享同一块地址空间和所有可用数据**的能力，这是进程所不具备的
* 线程要比进程更**轻量级**，更容易创建和撤销，操作起来更容易

### 线程的使用

* 多线程解决方案：

<img src=".\images\image-20240209142317700.png" alt="image-20240209142317700" style="zoom:50%;" />

​			以Web服务器为例，调度线程通过读入网络请求，然后选择空闲(睡眠)的工作线程来处理请求(阻塞变为就绪)

* 单线程解决方案

  单线程和多线程类似，区别就在于，单线程模型只有一个工作线程

* 状态机解决方案

  当管理线程时，状态机被用来描述线程的生命周期和状态转换，包括创建、就绪、运行、阻塞和终止等状态。操作系统根据这个状态机模型和外部事件来控制线程的状态转换，例如，当一个线程处于阻塞状态时，如果等待的事件发生，它会转换为就绪状态。

| 模型       | 特性                             |
| ---------- | -------------------------------- |
| 单线程     | 无并行性，性能较差，阻塞系统调用 |
| 多线程     | 有并行性，阻塞系统调用           |
| 有限状态机 | 并行性，非阻塞系统调用，中断     |

### 经典的线程模型

线程：进程中的执行单元，轻量级的进程

<img src=".\images\image-20240209151616609.png" alt="image-20240209151616609" style="zoom:50%;" />



<img src=".\images\image-20240209151759804.png" alt="image-20240209151759804" style="zoom:50%;" />

### 线程的系统调用

单线程--->通过某个库函数--->新的线程(Exit Join yield)--->线程消失

Exit：退出

Join：主程序等待线程调用结束继续执行

yield：允许此线程自动放弃CPU，让另一个线程运行(线程无法使用时钟中断让出CPU)

### POSIX线程

为了使编写可移植线程程序成为可能，IEEE在IEEE标准1003.1c中定义了线程标准

| 线程调用             | 描述                           |
| -------------------- | ------------------------------ |
| pthread_create       | 创建一个新线程                 |
| pthread_exit         | 结束调用的线程                 |
| pthread_join         | 等待一个特定的线程退出         |
| pthread_yield        | 释放CPU来运行另外一个线程      |
| pthread_attr_init    | 创建并初始化一个线程的属性结构 |
| pthread_attr_destory | 删除一个线程的属性结构         |

### 线程实现

* 在用户空间中实现线程

<img src=".\images\image-20240209153736668.png" alt="image-20240209153736668" style="zoom:50%;" />

```
所有的进程和线程全部在用户空间，内核完全不知道它们的存在，而进程和线程是在运行时系统之上实现的，运行时系统也叫运行时的环境，是用来管理线程运行过程(创建，终止，等待......)的集合，线程表用来跟踪进程中的线程，和内核中的进程表类似

优势：
	启动线程效率更高(不需要切换内核，不需要上下文切换，也不需要对内存高速缓存的刷新)
	允许每个进程有自己定制的调度算法
弊端：
	如何实现阻塞系统调用(系统调用存在于内核态)，比如当出现缺页错误的时候，会把该线程所在的整个进程中断掉
	不可能使用轮转调度的方式调度线程，换句话说就是多个线程只能一个个按顺序执行
```

* 在内核空间中实现线程

<img src=".\images\image-20240209162820380.png" alt="image-20240209162820380" style="zoom:50%;" />

```
在内核实现不需要运行时系统，转而将线程表放置内核，由内核来管理线程的运行过程

优势：
	可以进行阻塞系统调用
弊端：
	消耗太大(线程的创建，销毁等等)，为了防止消耗过大，对其进行了优化，比如销毁线程的时候并不是真正销毁，而是将其变为不可执行的线程，创建线程也不是真正的创建，而是将不可执行的线程变为可执行
```

* 在用户和内核空间中混合实现线程

<img src=".\images\image-20240209163658072.png" alt="image-20240209163658072" style="zoom:50%;" />

## 进程间通信

* 一个进程如何传递消息给其他进程
* 如何确保两个或多个线程之间不会相互干扰。例如，两个航空公司都试图为不同的顾客抢购飞机上的最后一个座位
* 第三个问题是数据的先后顺序问题，如果进程A产生数据并且进程B打印数据。则进程B打印数据之前需要先等待A产生数据之后才能打印

以后台打印程序为例：

一个后台打印程序。当一个进程需要打印某个文件时，它会将文件名放在一个特殊的后台目录中。另一个进程会定期的检查是否需要文件被打印，如果有，就打印并将该文件名从目录下删除

<img src=".\images\image-20240210145843154.png" alt="image-20240210145843154" style="zoom:50%;" />

### 竟态条件

类似于刚刚的情况，即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竟态条件

如何解决？

禁止一个或多个进程**在同一时刻**对共享资源（包括共享内存，共享文件等）进行读写

### 临界区

临界区是对共享区域进行访问的程序片段

* 任何时候两个进程不能同时处于临界区
* 不应对CPU的速度和数量做任何假设
* 位于临界区外的进程不得阻塞其他进程
* 不能使任何进程无限等待进入临界区

<img src=".\images\image-20240210152728599.png" alt="image-20240210152728599" style="zoom:50%;" />

### 忙等互斥

* 屏蔽中断
* 锁变量
* 严格轮询法
* Peterson算法
* TSL指令

#### 屏蔽中断(适合内核)

在单处理器系统上，最简单的解决方案是让每个进程在进入临界区后立即屏蔽所有中断

对于用户进程来说，屏蔽中断不适合，比如打开着QQ音乐，浏览器等，有其中一个进程进入临界区，其他所有进程都被中断，显然不可以

对内核来说，当它在执行更新或列表的几条指令期间屏蔽中断是很方便的 

#### 锁变量(适合用户空间)

锁变量是寻找一种软件层面的解决方案，是用户可编程性的解决方案

<img src=".\images\image-20240210154903887.png" alt="image-20240210154903887" style="zoom:50%;" />

锁变量也会出现竟态条件

<img src=".\images\image-20240210155202463.png" alt="image-20240210155202463" style="zoom:40%;" />

进程A还没有来得及更新锁变量，进程B就进行判断了

#### 严格轮询法

```c++
/* 进程0 */
while(true){		
    while(trun == 0){		//忙等待
        /* 进入临界区 */
        critical_region();
        turn=1;
        /* 离开临界区 */
        noncritical_region();
    }
}

/* 进程1 */
while(true){
    while(trun == 1){		//忙等待
        /* 进入临界区 */
        critical_region();
        turn=0;
        /* 离开临界区 */
        noncritical_region();
    }
}
```

严格轮询法在某种程度上确实可以视为一种检查锁变量是否被其他线程持有的方式。在这种方法中，线程会通过不断地检查某个标志位或变量的状态来判断是否可以进入临界区，这个标志位或变量可以被看作是一种锁变量。

严格轮询法的主要问题在于它会导致 CPU 资源的浪费，因为线程会不断地进行轮询，而不是在无法立即进入临界区时进行合理的等待。相比之下，互斥锁可以让线程在无法立即获得资源时进入阻塞状态，从而释放 CPU 给其他线程使用，降低了 CPU 资源的消耗。

只有在确定等待时间非常短的时候才使用忙等待

#### Peterson算法

```c++
#define N 2 //进程数量  两个进程 进程号分别为 0和1
int turn; //现在轮到谁了

int interested[N];

void enter_region(int process){	//进入临界区
    int other = 1 - process; //另一个进程号
    interested[process] = true;
    turn = process;
    //以上操作是进程进入临界区之前，初始化interested数组
    
    //空循环
    while(trun == process && interested[other] == true){}
    
    //进入临界区以后的操作
    //......
}

void leave_region(int process){	//离开临界区
    interested[process] = false;
}
```

#### TSL指令(硬件层面)

* 测试并加锁

  TSL RX,LOCK		执行TSL指令的CPU将会锁住内存总线，用来禁止其他CPU在这个指令结束之前访问内存

* 锁住内存总线和禁用中断不一样

<img src=".\images\image-20240210165541534.png" alt="image-20240210165541534" style="zoom:67%;" />

### 优先级反转问题

H进程（优先级高）和L进程（优先级低）两个进程，L进程运行到了临界区，此时H进程进入就绪态，那么CPU就会去调度H进程进入运行态，并且不在调度其他进程，此时H进程进入不了临界区，L进程出不了临界区    

