# 操作系统

## 操作系统总览

### 程序从创建到运行的过程

```c++
#include <stdio.h>
int main(){
    printf("hello world\n");
    return 0;
}
```

任何一个程序的生命周期都是从一个源文件开始的，源文件都是从main函数开始的，电脑上的任何信息都是以二进制的形式去记录的，那么源代码本质上是由0和1组成的一些序列，又将8位看作一个整体作为一个字节，用字节来表示程序中的字符

正是因为所有信息都是由二进制表示的，那么由二进制转为八进制，十进制，十六进制的编码来表示字符，比如ascall码，用这种编码来表示文本字符

#### 程序如何向操作系统迈进的？

将程序变为一个可执行的目标文件，以二进制的形式存入磁盘，就是程序向操作系统迈进的过程，这整个过程都是由编译器完成的，编译器在这个过程中分为了四步

* 预处理过程（生成 .i 文件）

  将我们需要引用的所有内容插入到源文件

  命令：gcc -E hello.c -o hello.i

  <img src=".\images\image-20240201191911893.png" alt="image-20240201191911893" style="zoom: 50%;" />

<img src=".\images\image-20240201191938589.png" alt="image-20240201191938589" style="zoom: 33%;" />

* 编译阶段（生成 .s 文件）

  将预处理过后的.i文件翻译成**汇编程序**，这一阶段**保证了操作系统与机器一对多的性质，因为汇编是所有操作系统都可以识别认证的**，此时不同的语言经过不同的编译器经过一系列过程变成了通用的汇编语言

  命令：gcc -S hello.i -o hello.s

  <img src=".\images\image-20240201192203154.png" alt="image-20240201192203154" style="zoom:50%;" />

<img src=".\images\image-20240201192223060.png" alt="image-20240201192223060" style="zoom:33%;" />

* 汇编阶段（生成 .o 文件）

  **汇编器**将 .s 文件翻译成**机器语言指令**

  命令：gcc -c hello.s -o hello.o

<img src=".\images\image-20240201193225204.png" alt="image-20240201193225204" style="zoom:50%;" />

<img src=".\images\image-20240201193244521.png" alt="image-20240201193244521" style="zoom:50%;" />

* 链接阶段（生成可执行文件）

**链接器**把需要调用的一些标准库文件(其他的目标文件)链接到文本文件当中，最终结果是得到一个可执行文件，然后加载到内存中，交给操作系统去执行

### 操作系统是如何区分和识别代码的

像一篇文章一样，要知道人物的心理是需要上下文的，操作系统也一样，也是通**过所谓的上下文来区分代码**，对于所有的程序，是只有上文，没有下文的

### 计算机常见硬件

处理器，内存，键盘，鼠标，显示器，网络接口，打印机等等所有的硬件在操作系统中都有对应的映射，除了像鼠标键盘这种I/O设备，程序员不会直接和硬件打交道，都会在硬件中封装一层软件，而这个软件就是**操作系统**，说白了，**操作系统就是建立一个和计算机硬件一一对应的计算机模型**

<img src=".\images\image-20240201201328871.png" alt="image-20240201201328871" style="zoom:50%;" />

操作系统是运行在内核态的，内核态其实就是操作系统的一种运行状态，操作系统是有硬件的访问权的，是可以执行机器中能够运行的任何指令；软件的其余部分全部运行在用户态，对接应用程序的一些接口，越靠近用户态上级的地方越容易编写；操作系统的主要目的是保护硬件



<img src=".\images\image-20240201202010013.png" alt="image-20240201202010013" style="zoom:50%;" />

​																							        简单个人计算机的组件

根据这个简单的个人计算机的组件可以抽象出最经典的系统硬件组成的模型

<img src=".\images\image-20240201202249116.png" alt="image-20240201202249116" style="zoom:50%;" />

* CPU：中央处理单元，处理和执行一些指令，计算机的大脑，处理的指令是从内存来的，任何时候CPU都是通过地址指向主存中的机器指令。
* 寄存器(PC)
  * 程序计数器：CPU不是直接与主存进行交互的，是通过程序计数器(寄存器)与主存交互的，程序计数器(寄存器)中存储指向下一条指令的地址
  * 通用寄存器：CPU从内存中获取指令的时间要远远大于CPU执行一条指令的时间，这个时候，寄存器会保存上一条指令执行的结果，程序记数器是通用寄存器的一环，通用寄存器还可以保存堆栈指针
  * 程序状态寄存器：跟踪当前系统的状态，在系统调用和输入输出起着关键作用

回到CPU，刚刚说到的内核态和用户态都存在于CPU中，通过程序状态寄存器中的一个二进制位可以控制CPU的状态是内核态还是用户态，当运行在内核态中，CPU可以执行指令集中的任何指令，并且可以使用硬件，如果运行在用户态中，有很多指令是被禁止的，比如内存保护相关指令，所以在这种状态下如何使用这些指令呢，那就需要用到用户接口程序来调用系统服务，所以用户接口程序就是转换内核态

### 取指单元,解码单元,执行单元

传统的CPU是读取指令，解码指令，执行指令三个环节一一执行，但是现代CPU是把三部分分开独立起来，在一个CPU中分为取指单元，解码单元，执行单元，为的是提高性能

**超标量流水线**：多个取指单元同时读取指令，进行解码，然后放到缓冲区，紧接着后面哪个执行单元空了就放到哪个单元，这种形式更偏向于无序的情况

<img src=".\images\image-20240201211616578.png" alt="image-20240201211616578" style="zoom:50%;" />

### 内存

内存的理想状态是存储空间又大，价格又便宜，而且让CPU读取信息又快，但是以目前的技术手段实现不了，就对内存进行了分层

<img src=".\images\image-20240201214220585.png" alt="image-20240201214220585" style="zoom:50%;" />

* 高速缓存：由硬件控制，是由主存分割出来的高速缓存行，高速缓存会检查需要的高速缓存行是否存在于高速缓存行中，因为寄存器和主存的访问时间相差还是很大的，而且CPU执行指令的时间远远快于从寄存器中读取指令的时间，高速缓存是在主存和寄存器之间做的缓存，就是为了提高寄存器读取指令的效率

  * 什么时候把新的内容存放进缓存？
  * 新的内容存在在缓存的哪一行？
  * 当我们需要新的空间作为缓存，应该移除哪块内容？
  * 移除的内容放在哪？

  由这四个问题引申出许多种缓存系统，在现代CPU种，主要有两种缓存

  * 第一级放在CPU内部，用来将已经解码的指令调入CPU的执行引擎
  * 第二种缓存，用来存放最近使用的关键字

* 主存：

  * RAM（随机访问存储器）
    * RAM是一种易失性存储器，这意味着当断电时，其中存储的数据会丢失。
    * RAM允许计算机随机地读取或写入数据，因此称为“随机存取存储器”。
    * RAM通常用于存储正在运行的程序和临时数据，包括操作系统和应用程序。
    * RAM的速度很快，但容量相对较小，且数据不持久。
  * ROM（只读存储器）
    * ROM是一种非易失性存储器，这意味着其中存储的数据不会因为断电而丢失。
    * ROM的内容在制造时被预先设定，并且一般情况下无法修改，因此称为“只读存储器”。
    * ROM用于存储固定的程序和数据，如计算机的基本引导程序（Bootstrap Loader）和固件（Firmware）等。
    * ROM通常用于存储一些需要在计算机启动时立即访问的数据和指令。

* 磁盘：访问速度慢，保存文件信息

  * 磁盘访问慢的原因是磁盘的构造（寻道时间，磁盘碎片化等等）

  <img src=".\images\image-20240202150516179.png" alt="image-20240202150516179" style="zoom:50%;" />

<img src=".\images\image-20240202150658014.png" alt="image-20240202150658014" style="zoom:50%;" />

<img src=".\images\image-20240202150803214.png" alt="image-20240202150803214" style="zoom:50%;" />

内存访问速度很快，但是成本大，存储空间小，使用很多的内存意味着消耗的成本很昂贵，所以就需要存储空间很大的磁盘来充当内存，但是磁盘的访问速度很慢，那么如何解决访问速度不匹配的问题呢？解决方法就是利用缓存，在磁盘中做了内存地址的映像，把经常访问的地址映射到主存，使其提高访问速度

### I/O设备

I/O设备主要分两大类，一类是我们可以看得到的设备，比如键盘鼠标，打印机，显示器等，另一类是一些控制器，USB控制器，硬盘控制器，这些控制器就是一个个小芯片，这些控制器对于I/O设备来说就是操作系统，目的是为了屏蔽各种物理细节

实现输入和输出的方式有三种：

* 忙等待

  当一个设备要输入的时候，操作系统将输入的控制权交给该设备，该设备去占据CPU，其他的输入设备只能等待，当该设备工作完成，再将CPU的控制权交还给调用者

* 中断

  中断是为了解决忙等待的问题，在忙等待中，当一个设备正在执行输入输出操作时，操作系统或应用程序需要不断地轮询设备状态，从而导致 CPU 被长时间占用。而中断机制允许设备在需要时发送中断请求，CPU 可以继续执行其他任务，直到设备就绪并触发中断。

  <img src=".\images\image-20240202161636854.png" alt="image-20240202161636854" style="zoom:50%;" />

  一开始磁盘驱动器会在CPU中下一个驱动

  1:CPU告诉磁盘控制器，磁盘可以开始工作了

  2：发送中断信号到中断控制器，信号的接受与否看该信号的优先级

  3 4: 中断控制器接收信号，将信号传给CPU，CPU执行中断信号，此时会记录被中断设备在结   		束运行时的一些信息和地址，这些信息会保存到被中断设备的寄存器中，然后CPU瞬间切		换到内核态 

* 直接存储器访问（DMA）

### 将设备驱动器装入操作系统

* 第一个途径是将内核与设备启动程序重新连接，然后重启系统
* 第二个途径是在一个操作系统文件中设置一个入口，通知该文件需要一个设备驱动程序，然后重新启动系统。在重启系统时，操作系统会寻找有关的设备启动程序并把它装载
* 第三个途径是操作系统能够在运行时接收新的设备驱动程序并立刻安装，无需重启操作系统

### 总线(BUS)

* 总线就跟公共汽车一样
* 公共汽车的站点----------多个设备或者接入点
* 乘客------------传输的数据包
* 车是有容量的，所以传输的信息也是有容量的---------字节块
* 车辆谁先走，谁后走，走哪站，需要有顺序，有规定----------控制器 

<img src=".\images\image-20240202165745634.png" alt="image-20240202165745634" style="zoom:50%;" />

### **硬件支持系统，系统管理硬件**

* 操作系统其实就是一个建立在应用程序和硬件之间的一道桥梁
* 基本功能：
  * 防止硬件被滥用
  * 通过一种比较简单的机制匹配对应的应用程序，进而控制复杂的硬件
* 对硬件进行抽象
  * 进程(处理器，主存，I/O设备)
  * 虚拟内存(主存和磁盘)
  * 文件(I/O设备)

#### 进程

* 进程的本质就是操作系统执行的一个程序

* 与进程相关

  * **地址空间------存放的是可执行程序**
  * **资源集-------通常包括寄存器，打开文件的清单，突发的报警，有关的进程清单和其他需要执行程序的信息**

  

  假设一种场景

  ​	用户启动一个视频剪辑程序，指示它按照某种格式转换视频，然后去浏览网页，同时，一个	检查电子邮件的后台进程被唤醒并开始运行

  ​	这是三个独立的活跃进程，CPU不是同时执行这三个进程，而是不断轮换，挂起一个进程，执行一个进程，只不过是轮换的时间非常快，在切换的时候，也叫做中断，**在挂起一个进程转而执行另一个进程的时候，会将挂起进程当前的所有状态信息保存在操作系统的进程表中**

  

  进程挂起包括：

* 进程的地址空间----磁盘映像

* 进程表项（进程当前的所有状态信息存储在进程表中）

  与进程管理有关的最关键的系统调用往往是决定着进程的创建和终止的系统调用

  

  进程间通信

* 合作完成某些作业的相关进程经常需要彼此通信来完成

* 那么信息丢失怎么办？

  * 利用定时器来防止信息丢失，当进程A给进程B发送信息后，定时器开始启动，在若干秒后，操作系统会向进程B发送一个确认通知，如果进程B没收到刚刚信息，操作系统会向进程A发送警告，然后进程A重新发送信息，在等待确认的过程中进程A会被挂起 

#### 线程

* 线程是操作系统能够运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位
* 为什么会有线程的概念？
  * 进程的颗粒度太大，线程主要共享的是进程的地址空间，进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同

#### 地址空间

在一个非常简单的操作系统中，仅仅有一个应用程序运行在内存中，为了运行第二个应用程序，需要把第一个应用程序移除才能把第二个程序装入内存

复杂一些的操作系统会允许多个应用程序同时装入内存中运行，为了防止应用程序之间相互干扰，就引出了地址空间，每个程序都有属于自己的地址空间

#### 虚拟内存

进程直接访问物理地址会带来不可预估的风险

物理内存资源是宝贵且非常有限

内存分配时，连续内存分配会产生很多难以分配的内存碎片

为了避免这些问题，从而引出了虚拟内存

虚拟内存是一种解决方案，用于解决计算机系统中的内存管理和资源限制问题

1. **扩大可用内存空间**：虚拟内存允许程序使用比物理内存更大的地址空间，因为它可以使用硬盘空间作为临时的扩展内存。
2. **提高系统的响应速度和效率**：通过将不活跃的内存页面存储到硬盘上，并在需要时将其重新加载到物理内存中，虚拟内存能够优化内存的使用，提高系统的整体性能和响应速度。

形象理解：

想象你有一个小房子（代表你的计算机的物理内存），这个房子有一定的空间，但是不够大。现在你想装入很多家具（代表程序和数据），但是家具太多，无法一次性全部放进房子里。

虚拟内存就好像你在房子外面有一个储藏室（代表硬盘），你可以把一部分不经常使用的家具放到储藏室里。当你需要某件家具时，你可以把它从储藏室取出放到房子里使用，同时可以把另一件不需要的家具放回储藏室。这样，你的房子看起来就好像有很大的空间一样，虽然实际上你只是用了有限的房间和储藏室。

这个例子中：

- 房子就是物理内存，有限的、可见的内存空间。
- 储藏室就是硬盘，无限的、不可见的存储空间。
- 家具就是程序和数据，需要被存储和使用。

虚拟内存的作用就是扩大了你可用的内存空间，使得你能够运行更多的程序和处理更多的数据，而不受物理内存大小的限制。

#### 文件

几乎所有操作系统都支持的另一个关键概念就是文件系统

对文件的所有操作几乎全部需要系统调用

操作系统的一项主要功能是屏蔽磁盘和其他I/O设备的细节特性，给程序员提供一个良好，清晰的独立于设备的抽象文件模型

保存文件的地址：目录

<img src=".\images\image-20240203145514627.png" alt="image-20240203145514627" style="zoom:50%;" />

#### 管道

是一种虚文件，用来连接两个进程

<img src=".\images\image-20240203150428747.png" alt="image-20240203150428747" style="zoom:50%;" />

#### 并发和并行

并发和并行是既相似又有区别的两个概念

​	并行是指两个或者多个事件在同一时刻发生

​	并发是指两个或多个事件在同一时间段内交替发生

#### 系统调用

操作系统提供两种功能

​	为用户提供应用程序抽象

​	管理计算机资源

只有系统调用能进入内核态，操作硬件

<img src=".\images\image-20240203152103526.png" alt="image-20240203152103526" style="zoom:50%;" />

假如现在是一个读文件的C语言代码

1 2 3：传入读取文件相关的参数

4：调用函数

5：调用之后，把代码进行分区放置到虚拟内存（因为是临时数据）

6：进入内核态

7 8：内核态中执行系统调用

9：返回给用户

系统调用的分类：

* 用于进程管理的系统调用

* 用于文件管理的系统调用
* 用于目录管理的系统调用

#### 操作系统结构

* 单体结构(最常用)

  单体结构和我们平时写的代码一样，是以单一的程序来进行运行的

  优点：调用任何一个所需要的程序都非常高效

  缺点：成千上万的调用显得臃肿，笨拙，只要系统发生故障，任何程序将不可用，这往往是灾			难性的

<img src=".\images\image-20240203153411362.png" alt="image-20240203153411362" style="zoom:50%;" />

* 分层系统

  利用层级来分隔不同的功能，分层结构中的所有功能都存放于内核态中

* 微内核

  传统上，所有层都在内核中，但是这样做没有必要

  尽可能减少内核态中功能可能是更好的做法

  只有一个模块----微内核------运行在内核态，其余模块可以作为普通用户进程运行在用户态

  <img src=".\images\image-20240203154053721.png" alt="image-20240203154053721" style="zoom:50%;" />

  

* 客户-服务端系统

<img src=".\images\image-20240203154230152.png" alt="image-20240203154230152" style="zoom:50%;" />