# 文件系统的管理和优化

## 磁盘空间管理

分配n个字节的连续磁盘空间；或者把文件拆分成多个并不一定连续的块

在存储管理系统中，主要有分段管理和分页管理两种方式

按连续字节序列存储文件

​	当文件扩大时，有时候需要在磁盘上移动文件

内存中分段

​	相对于把文件从磁盘的一个位置移动到另一个位置，内存中段的移动操作要快很多

因此几乎所有文件系统都是把文件分割成固定大下的块进行存储

### 块大小

那么块的大小是多少？

​	按照磁盘组织方式，扇区，磁道和柱面显然都可以作为分配单元，那到底按照哪种方式呢？

如果分配的块太大会浪费空间；分配的块太小会浪费时间

如今一般都是使用扇区

那么块分完了，接下来就是哪些是空闲块，哪些不是

### 记录空闲块

位图    链表

<img src="..\images\image-20240305202807415.png" alt="image-20240305202807415" style="zoom:50%;" />

两种方式的区别：

​	使用磁盘块链表，链表也是一块一块的

​	位图，占用空间小

如果空闲块是长期连续的话，那么空闲列表可以改成记录连续分块而不是单个的块。

​	第一个空闲块的地址和空闲块的计数

如果磁盘严重碎片化，那么跟踪连续分块要比跟踪单个分块运行效率低

空闲链表

只有一个指针块保存在内存中，创建文件时，所需要的块从指针块中取出，当它用完时，将从磁盘中读取一个新的指针块。类似地，删除文件时，文件的块将被释放并添加到主存中的指针块中。当块被填满时，写回磁盘

<img src="..\images\image-20240305204313045.png" alt="image-20240305204313045" style="zoom:50%;" />

这种方式可能会造成多次的磁盘IO，解决方案：拆分完整的指针块，当发现内存中的空闲块不够了，就直接进行一次磁盘IO，重新读取完整的空闲块（对临时文件的优化）

## 磁盘配额

在多用户操作系统中，为了防止一些用户占用太多的磁盘空间，多用户操作通常提供一种磁盘配额

系统管理员为每个用户分配最大的文件和块分配，并且操作系统确保用户不会超过其配额

用户在打开一个文件，操作系统要打开文件找到文件的属性和磁盘地址，并且把该文件送入内存中

<img src="..\images\image-20240305205829755.png" alt="image-20240305205829755" style="zoom:50%;" />

## 文件系统备份

文件系统的毁坏要比计算机的损坏严重很多。无论是硬件还是软件的故障，只要计算机文件系统被破坏，要恢复起来都是极其困难的，甚至是不能能的。

磁盘备份主要要处理的问题

​	从意外的灾难中恢复

​	从错误的操作中恢复

备份引发的问题

​	是要备份整个文件还是仅备份一部分呢？

​	对上一次未修改过的文件再进行备份是一种浪费

​	待转储的往往是海量数据，那么在将其写入磁带之前对文件进行压缩就很重要

​	对正在使用的文件系统做备份是很难的

### 物理转储

从磁盘的0块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的

优点：简单，极为快速

缺点：全量备份（把未修改的也备份了），不能跳过指定目录，也不能增量转储，也不能恢复个人文件的请求

出现坏块：把磁盘末尾的空闲块拿来替换

大多数情况下不会使用物理转储，而使用逻辑转储

### 逻辑转储

从一个或几个指定的目录开始，递归转储自指定日期开始后更改的文件和目录

<img src="..\images\image-20240306164247446.png" alt="image-20240306164247446" style="zoom:50%;" />

方块代表目录，圆圈代表文件，蓝色代表未修改，黄色代表修改

逻辑转储就是维护了一个以inode为索引的位图



逻辑转储算法执行的四个阶段

1：第一阶段从起始目录开始检查其中所有的目录项。对每一个未修改过的文件，该算法将在位图中标记其inode（文件修改后，往上的目录也要修改）

![image-20240306164729016](..\images\image-20240306164729016.png)

2：再次递归遍历目录树，标记未修改的目录

![image-20240306165300680](..\images\image-20240306165300680.png)

以上两步之后，就可以知道剩下未标记的就是修改过的文件和目录，需要被转储

3：在第二步的基础上，以节点号为序，标记文件，得到需要转储的目录

<img src="..\images\image-20240306170238000.png" alt="image-20240306170238000" style="zoom:50%;" />

4：把转储出来的目录下的文件进行转储

## 文件系统一致性

文件系统的一致性是影响可靠性的一个因素

为了处理文件系统一致性问题，大部分计算机都会有应用程序来检查文件系统的一致性。例如，UNIX有fsck，Windows有sfc，每当引导系统时，都可以运行该程序

检查

​	块的一致性检查

​	文件的一致性检查

检查一致性-----两张表

​	第一个表中的计数器跟踪该块在文件中出现的次数

​	第二张表中的计数器记录每个块在空闲列表，空闲位图中出现的频率

<img src="..\images\image-20240307152150521.png" alt="image-20240307152150521" style="zoom:67%;" />



当系统出现崩溃的时候

<img src="..\images\image-20240307152332585.png" alt="image-20240307152332585" style="zoom:50%;" />

​																		      块丢失

出现块丢失一般的解决方法：检验程序将该块记录为空闲块，块丢失不会造成严重的问题



<img src="..\images\image-20240307153353027.png" alt="image-20240307153353027" style="zoom:50%;" />

​																			空闲块出现+2

解决方法：重新建立空闲表



<img src="..\images\image-20240307153501351.png" alt="image-20240307153501351" style="zoom:50%;" />

​																	     使用的块出现+2

先分配空闲磁盘，将5号磁盘块内容复制到里面，具体的文件问题由用户自己检查



除了检查磁盘块的一致性，还会去检查目录系统 

这时候会用到一张计数器表，但这时是一个文件对应一个计数器，程序从根目录开始检验，沿着目录树向下查找，检查文件系统的每个目录

在检验程序完成后，会得到一张由inode索引的表，说明每个文件和目录的包含关系

问题

​	如果inode节点的链接计数大于用户目录项个数，这时即使所有文件从目录删除，这个计数仍然不是0，inode不会被删除，这会造成磁盘浪费

​	如果同一个文件链接两个目录项，但是inode链接计数只为1，删除任何一个目录项，对应inode链接计数变为0

## 文件系统性能优化

### 文件系统的第一个优化：高速缓存

<img src="..\images\image-20240307160752843.png" alt="image-20240307160752843" style="zoom:50%;" />



高速缓存一般的执行逻辑（哈希表），通过哈希表指向磁盘块，磁盘块之间也是可以相互访问

<img src="..\images\image-20240307161158645.png" alt="image-20240307161158645" style="zoom:50%;" />

### 块提前读（只适用于顺序读取）

许多文件是顺序读取，如果读取到块k，当完成操作后，会先检查高速缓存，确定块k+1是否存在于高速缓存，如果不在，文件系统会为k+1安排一个预读取

### 减少磁盘臂运动

把有可能顺序访问的块放在同一个柱面上

<img src="..\images\image-20240307162140299.png" alt="image-20240307162140299" style="zoom:50%;" />

### 磁盘碎片整理

移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。

Windows碎片整理程序：defrag



