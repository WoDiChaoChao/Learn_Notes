# 文件系统的实现

最重要的问题是记录各个文件分别用到了哪些磁盘块

分配背后的主要思想是有效利用文件空间和快速访问文件

## 连续分配

<img src="..\images\image-20240303164802731.png" alt="image-20240303164802731" style="zoom:50%;" />

把每个文件当作连续的数据块分配在磁盘上，从0号位置开始写入，每个块都有有固定空间，假设一个块1kb，一个文件占了1.5kb，即使第二个块没占满，新的文件依旧从新的块开始

优点：实现简单，性能强，读取性能很强

缺点：当存取文件数据很多，会产生很多碎片，当中间文件删除的时候，新的文件还是会从末尾块存储，不会去挤压删除文件的块

## 链表分配

为每一个文件构建一个磁盘块的链表，每个块的第一个字作为指针，来指向下一个块的地址，链表更加灵活，解决了连续分配方案中不能充分利用所有磁盘块的问题

但链表也有一定问题，首先指针本身会占据一些字节，会使存放文件数据的字节数不是2的整数次幂，其次在读取文件的时候，要把指针数据全部消掉，增加了查找的开销

<img src="..\images\image-20240303170638757.png" alt="image-20240303170638757" style="zoom:50%;" />



<img src="..\images\image-20240303170726043.png" alt="image-20240303170726043" style="zoom:50%;" />

## 使用内存表进行链表分配（FAT）

<img src="..\images\image-20240303171555931.png" alt="image-20240303171555931" style="zoom:50%;" />

取出每个磁盘块中的指针字，放入内存的一个表中

优点：既可以顺序存储，也可以随机访问，在目录项中只记录起始块号就可

缺点：整个链表要放到内存中，因为是存储在内存中，占用空间太大，不适合很大的磁盘，分块会很多

## INODE

<img src="..\images\image-20240303172335139.png" alt="image-20240303172335139" style="zoom:67%;" />

为每一个文件包含哪些磁盘块做了一个记录，每个文件都有INODE属性，INODE只有在文件打开的时候才会存入内存，这就大大降低了内存的消耗

问题：每个结点都有一个固定大小的磁盘地址，如果文件增长到超过了固定大小的磁盘，怎么办？

解决方案：空出最后几个磁盘地址，不指向文件数据，去指向其他的块

# 目录的实现

文件只有打开后才能够被读取。在文件打开后，操作系统会使用用户提供的路径名来定位磁盘中的目录

目录通过将文件的ASCII码名称与文件的实际存储位置及其他必要信息建立映射，为操作系统提供了有效的手段来定位和管理文件

目录的设计：

​	把文件属性放到目录项中

<img src="..\images\image-20240304110845955.png" alt="image-20240304110845955" style="zoom:50%;" />



​	对于采用INODE的系统，会把INODE存储在属性中而不是目录项中

<img src="..\images\image-20240304111019833.png" alt="image-20240304111019833" style="zoom:50%;" />

以上都是基于数组实现的，那么空间大小是固定的，但是对于文件名来说是变长的，这又怎么实现呢？

放弃目录项大小相同的设计，怎么判断长度呢？

<img src="..\images\image-20240304111536581.png" alt="image-20240304111536581" style="zoom:50%;" />

、

<img src="..\images\image-20240304111834813.png" alt="image-20240304111834813" style="zoom:50%;" />

这种方法还是有问题：会发生缺页，在删除一个文件之后，再新建文件，新建文件大小是大概率不会和删除文件大小相等的，那空出来的空间怎么办？这和连续分配中出现的问题是一样的

# 共享文件

当多个用户在同一个项目中工作时，他们通常需要共享文件

共享文件如何实现？做一个链接

<img src="..\images\image-20240304145225131.png" alt="image-20240304145225131" style="zoom:67%;" />

产生的代价：一旦文件之间相互链接，就不再是一个树形结构了，而变成了图

还可能破坏共享目的，目录中包含磁盘地址，如果修改了目录本身，那么其他的共享目录是看不见的

<img src="..\images\image-20240304150907850.png" alt="image-20240304150907850" style="zoom:50%;" />

两种解决方案：

​	第一种：磁盘块不列入目录中，而是放在与文件本身相关联的INODE中

<img src="..\images\image-20240304151616632.png" alt="image-20240304151616632" style="zoom:50%;" />

​	第二种：建立一个类型为LINK的新文件，放在B的目录下，使得B和C建立连接，当B读取文件时，操作系统先检查B的目录下有无LINK文件，进而找到链接的文件，再去读取文件--------符号链接

# 日志结构文件系统

技术的改变会给当前的文件系统带来压力，CPU变得越来越快，磁盘会变得越来越大并且越来越便宜，内存容量也是指数级增长，但是磁盘的寻道时间并没有获得提高

解决的问题：

​	不断增长的系统内存

​	顺序I/O性能胜过随机I/O性能

​	现有低效率的文件系统

​	文件系统不支持RAID（虚拟化）

<img src="..\images\image-20240304154533780.png" alt="image-20240304154533780" style="zoom:67%;" />



<img src="..\images\image-20240304154556161.png" alt="image-20240304154556161" style="zoom:67%;" />

# 日志文件系统

记录系统下一步将要做什么的日志，怎么记录呢？

比如删除一个文件

在UNIX中或者Linux中：

​	在目录中删除文件

​	释放inode到空闲inode池

​	将所有磁盘块归还给空闲磁盘池

这三步是原子性操作

一般文件系统崩溃后必须运行fsck（文件系统一致性检查）实用程序，检查的是日志文件，检查的内容是用户操作和文件中存储的操作是否一致

为了让日志能够正确工作，被写入的日志操作必须是幂等的（幂等：可以重复操作并不会带来破坏）



# 虚拟文件系统

即使在同一台计算机上或者在同一个操作系统下，都会使用很多不同的文件系统

Windows中的主要文件系统是NTFS文件系统，但不是说Windows只有NTFS文件系统，它还有一些其他的例如旧的FAT-32或者FAT-16驱动器或分区

UNIX把多种文件系统整合到一个统一的结构中。一个Linux系统可以使用ext2作为根文件系统，ext3分区装载在/usr下，另一块采用ReiserFS文件系统的硬盘装载到/home下等等

UNIX操作系统使用一种虚拟文件系统来尝试将多种文件系统构成一个有序的结构

<img src="..\images\image-20240305193623838.png" alt="image-20240305193623838" style="zoom:50%;" />



<img src="..\images\image-20240305201655600.png" alt="image-20240305201655600" style="zoom:50%;" />