# 死锁

* 独占性：在同一时刻，某个资源只能由一个进程使用

## 资源

需要排他性使用的对象称为资源（resource）

* 可抢占资源

  从拥有它的进程中抢占而不会造成其他影响

* 不可抢占资源

  除非发生错误或异常，否则进程无法抢占指定资源

可抢占资源发生死锁的时候可以很好解决，所以死锁一般与不可抢占资源有关

使用资源的一般步骤：请求获取，使用，释放

## 资源获取

对于一些数据库系统中的记录这类资源来说，应该由用户进程来对其进行管理

管理方法：

* 信号量
* 互斥锁

获取资源的顺序可能会导致死锁

```c++
void procedureA{
down(a);
down(b);
useResourse_a();
useResourse_b();
up(&a);
up(&b);
}

void procedureB{
down(b);
down(a);
useResourse_b();
useResourse_a();
up(&b);
up(&a);
}
```

进程A使用了资源a，进程B使用了资源b，然而进程A后面要使用资源b,需要进程B等待释放资源b，但是进程B后面要使用资源a，也需要等待进程A释放资源a，这就造成了进程A永远访问不了资源b，进程B永远访问不了资源a

## 死锁

如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁

* 资源死锁

  死锁进程集合中的每个进程都在等待另一个进程已经占有的资源，但是由于所有进程都不能运行，它们之中任何一个资源都无法释放资源，所以没有一个进程可以被唤醒

  资源死锁是最常见的类型
  
* 两阶段加锁

  如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的

* 通信死锁

  发消息的时候发生的死锁，比如A向B发送了消息，A阻塞等待B的响应；如果消息丢失，B接收不了，那么A会等待B的反馈，B会等待A的消息

  避免方式：时钟

  并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁（路由器的缓冲区满了，消息发不出去）

* 活锁

  某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌性地释放已经获得的锁，然后等待非常短的时间再次尝试获取

  活锁的问题：两个进程都访问同一个资源，结果都礼貌地释放，又因为两个进程的定时器一样，在下次检测的时候还是检测到了对方，但实际上这个资源没有被任何进程利用

* 饥饿

  如果一个进程一直得不到资源，就会产生饥饿，比如一台打印机，小文件优先高，大文件优先级低，结果来的全是小文件

**总而言之，如果一个进程因为等待另一个进程的某些原因而造成自己一直在阻塞等待的情况都称为死锁**

### 资源死锁的条件

**互斥条件**：每个资源都被分配给了一个进程

**保持和等待条件**：已经获取资源的进程被认为能够获取新的资源（以上述例子：获取a资源的进程a被操作系统认为可以获取资源b，但是b没有被释放，只不过需要等待）

**不可抢占条件**：分配给一个进程的资源不能强制地从其他进程抢占资源，它只能由占有它的进程显式释放

**循环等待**：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源

**解决死锁问题可以通过解决死锁产生的四个条件之一**

## 死锁模型

圆形来表示进程；方形表示资源

<img src="..\images\image-20240313165337840.png" alt="image-20240313165337840" style="zoom:50%;" />

​                                                               R资源正在被进程A占用



<img src="..\images\image-20240313165520256.png" alt="image-20240313165520256" style="zoom:50%;" />

​                                                                进程B正在请求资源S

**死锁模型**：

<img src="..\images\image-20240313165633171.png" alt="image-20240313165633171" style="zoom:50%;" />

## 避免死锁

<img src="..\images\image-20240313165711194.png" alt="image-20240313165711194" style="zoom:50%;" />

进程按照顺序执行，完全可以避免死锁，但是这是不现实的，没有并行的存在

* 仔细地分配资源
* 忽略影响
* 检测死锁并恢复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题
* 通过破坏死锁产生的四个条件之一

### 忽略影响（鸵鸟算法）

发生死锁时忽略其影响，假装没有发生死锁，死锁发生的频率低并且是由于操作系统，编译器等等原因发生的死锁，可以进行忽略

### 死锁的恢复和检测

在检测到死锁出现后，对其进行恢复

#### 死锁检测

**死锁检测**：

每种类型一个资源的检测方式

可以通过构造一张资源分配表来检测

​	两个矩阵：当前分配的矩阵，待请求的矩阵

​	当前分配的矩阵每一行代表这一种类型的资源已经被分配

​	待请求的矩阵每一行代表这个进程接下来要请求的资源

​	通过两张表的计算来判断是否出现死锁了

**何时检测？**

* 每当有资源请求时就去检测，这种方式会占用昂贵的CPU时间
* 每隔k分钟检测一次，或者当CPU使用率降低到某个标准（高到某个标准或者CPU空闲的时候）下去检测

#### 死锁恢复

通过抢占进行恢复

​	在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程

通过回滚进行恢复

​	如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程

杀死进程恢复

​	最简单有效的解决方法是直接杀死一个死锁进程

### 仔细地分配资源避免死锁

**单个资源的银行家算法**：

<img src="..\images\image-20240313223150257.png" alt="image-20240313223150257" style="zoom:50%;" />

假设银行总额度为15，假设A=4，B=5，C=3，D=1，全部为13，那么银行总额度就剩下2，A还可以贷2，那A贷完之后银行就没钱了，这时银行处于一种不安全的情况

基于以上情况，银行可以**有选择地进行放贷**

操作系统也是按照这个思路来解决资源分配的，当有一个进程请求这个资源可能会造成不安全，那么就先等一等，让不会造成不安全的进程请求先来

### 破坏死锁产生的条件

死锁本质上是无法避免的，因为它需要获得未知的资源和请求

但是死锁的出现满足四个条件

* 互斥
* 保持和等待
* 不可抢占
* 循环等待

#### 破坏互斥条件

破坏互斥条件就是多个进程可以同时访问一个资源，比如打印机使用假脱机技术来破坏互斥条件

#### 破坏保持等待状态

如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁

​	让所有的进程开始执行前请求全部资源，如果所需的资源可用，进程会完成资源的分配并运行到	结束，这种方式没有办法合理地利用资源

​	进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源

#### 破坏不可抢占条件

通过虚拟化破坏不可抢占条件

虚拟化：把不可抢占的资源映射成可抢占的资源

#### 破坏循环等待条件

* 制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源（限制有点过于严苛）
* 将所有的资源统一编号

